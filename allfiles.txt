filename: package.json
filecontent:
{
  "name": "vinyl-peer-monorepo",
  "version": "0.0.1",
    "authors": [
    "KDLabs"
  ],
  "private": true,
  "type": "module",
  "description": "The monorepo for the Vinyl Peer project, including CLI, plugins, and protocol.",
  "license": "MIT",
  "scripts": {
    "install:all": "pnpm install --recursive",
    "build": "pnpm run --recursive build",
    "test": "pnpm run --recursive test",
    "format": "prettier --write .",
    "clean": "rimraf packages/*/dist"
  },
  "workspaces": [
    "packages/*",
    "examples/*"
  ],
  "packageManager": "pnpm@9.12.3+sha512.cce0f9de9c5a7c95bef944169cc5dfe8741abfb145078c0d508b868056848a87c81e626246cb60967cbd7fd29a6c062ef73ff840d96b3c86c40ac92cf4a813ee",
  "prettier": {
    "printWidth": 100,
    "tabWidth": 2,
    "useTabs": false,
    "semi": true,
    "singleQuote": false
  },
  "devDependencies": {
    "rimraf": "^5.0.0",
    "@types/express": "^5.0.2",
    "typescript": "^5.7.3",
    "@types/node": "^22.13.0",
    "@types/react": "^19.0.8",
    "@types/react-dom": "^19.0.3",
    "prettier": "^3.5.0",
    "vitest": "^3.0.5"
  }
}
filename: generated-sdk/types.d.ts
filecontent:
/**
 * AUTO‐GENERATED shared types for Vinyl SDK
 * Do not edit by hand.
 */

export type QueryParams = Record<string, any>;
export type RequestBody = any;
export type ResponseData = any;

export interface SdkClient {
  /**
   * Simple HTTP client with baseURL pointing to your Vinyl node.
   * e.g. const client = createSdkClient("http://localhost:3001")
   */
  get<T = ResponseData>(path: string, params?: QueryParams): Promise<T>;
  post<T = ResponseData>(path: string, body?: RequestBody, params?: QueryParams): Promise<T>;
  put<T = ResponseData>(path: string, body?: RequestBody, params?: QueryParams): Promise<T>;
  delete<T = ResponseData>(path: string, params?: QueryParams): Promise<T>;
}

filename: generated-sdk/sdk.ts
filecontent:
/**
 * AUTO‐GENERATED VINYL SDK
 * Do not edit by hand.
 */

import fetch from "node-fetch";
import { SdkClient, QueryParams, RequestBody, ResponseData } from "./types";

/**
 * Create a simple SdkClient using fetch
 */
export function createSdkClient(baseURL: string): SdkClient {
  return {
    async get<T = ResponseData>(path: string, params?: QueryParams): Promise<T> {
      const url = new URL(path, baseURL);
      if (params) Object.entries(params).forEach(([k, v]) => url.searchParams.append(k, String(v)));
      const res = await fetch(url.toString(), { method: "GET" });
      return res.json();
    },
    async post<T = ResponseData>(path: string, body?: RequestBody, params?: QueryParams): Promise<T> {
      const url = new URL(path, baseURL);
      if (params) Object.entries(params).forEach(([k, v]) => url.searchParams.append(k, String(v)));
      const res = await fetch(url.toString(), {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: body ? JSON.stringify(body) : undefined
      });
      return res.json();
    },
    async put<T = ResponseData>(path: string, body?: RequestBody, params?: QueryParams): Promise<T> {
      const url = new URL(path, baseURL);
      if (params) Object.entries(params).forEach(([k, v]) => url.searchParams.append(k, String(v)));
      const res = await fetch(url.toString(), {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: body ? JSON.stringify(body) : undefined
      });
      return res.json();
    },
    async delete<T = ResponseData>(path: string, params?: QueryParams): Promise<T> {
      const url = new URL(path, baseURL);
      if (params) Object.entries(params).forEach(([k, v]) => url.searchParams.append(k, String(v)));
      const res = await fetch(url.toString(), { method: "DELETE" });
      return res.json();
    }
  };
}

/**
 * POST /api/music/upload
 */
export async function post_api_music_upload(client: SdkClient, body?: RequestBody): Promise<ResponseData> {
  return client.post(`/api/music/upload`, body);
}

/**
 * POST /api/music/search
 */
export async function post_api_music_search(client: SdkClient, body?: RequestBody): Promise<ResponseData> {
  return client.post(`/api/music/search`, body);
}

/**
 * GET /api/music/recommendations/:cid
 */
export async function get_api_music_recommendations_Bycid(cid: string, client: SdkClient, queryParams?: QueryParams): Promise<ResponseData> {
  return client.get(`/api/music/recommendations/${cid}`, queryParams);
}

/**
 * GET /api/music/metadata/:cid
 */
export async function get_api_music_metadata_Bycid(cid: string, client: SdkClient, queryParams?: QueryParams): Promise<ResponseData> {
  return client.get(`/api/music/metadata/${cid}`, queryParams);
}

/**
 * GET /api/music/all
 */
export async function get_api_music_all(client: SdkClient, queryParams?: QueryParams): Promise<ResponseData> {
  return client.get(`/api/music/all`, queryParams);
}

/**
 * GET /api/music/stats
 */
export async function get_api_music_stats(client: SdkClient, queryParams?: QueryParams): Promise<ResponseData> {
  return client.get(`/api/music/stats`, queryParams);
}

/**
 * GET /api/music/stream/:cid
 */
export async function get_api_music_stream_Bycid(cid: string, client: SdkClient, queryParams?: QueryParams): Promise<ResponseData> {
  return client.get(`/api/music/stream/${cid}`, queryParams);
}

/**
 * POST /api/music/playlist
 */
export async function post_api_music_playlist(client: SdkClient, body?: RequestBody): Promise<ResponseData> {
  return client.post(`/api/music/playlist`, body);
}

/**
 * GET /api/music/playlist/:name
 */
export async function get_api_music_playlist_Byname(name: string, client: SdkClient, queryParams?: QueryParams): Promise<ResponseData> {
  return client.get(`/api/music/playlist/${name}`, queryParams);
}

/**
 * PUT /api/music/playlist/:name
 */
export async function put_api_music_playlist_Byname(name: string, client: SdkClient, body?: RequestBody): Promise<ResponseData> {
  return client.put(`/api/music/playlist/${name}`, body);
}

/**
 * DELETE /api/music/playlist/:name
 */
export async function delete_api_music_playlist_Byname(name: string, client: SdkClient, queryParams?: QueryParams): Promise<ResponseData> {
  return client.delete(`/api/music/playlist/${name}`, queryParams);
}

/**
 * GET /api/analytics/snapshot
 */
export async function get_api_analytics_snapshot(client: SdkClient, queryParams?: QueryParams): Promise<ResponseData> {
  return client.get(`/api/analytics/snapshot`, queryParams);
}

/**
 * GET /api/analytics/top-file-types
 */
export async function get_api_analytics_topfiletypes(client: SdkClient, queryParams?: QueryParams): Promise<ResponseData> {
  return client.get(`/api/analytics/top-file-types`, queryParams);
}

/**
 * POST /api/vns/register
 */
export async function post_api_vns_register(client: SdkClient, body?: RequestBody): Promise<ResponseData> {
  return client.post(`/api/vns/register`, body);
}

/**
 * GET /api/vns/resolve/:name
 */
export async function get_api_vns_resolve_Byname(name: string, client: SdkClient, queryParams?: QueryParams): Promise<ResponseData> {
  return client.get(`/api/vns/resolve/${name}`, queryParams);
}

/**
 * DELETE /api/vns/delete/:name
 */
export async function delete_api_vns_delete_Byname(name: string, client: SdkClient, queryParams?: QueryParams): Promise<ResponseData> {
  return client.delete(`/api/vns/delete/${name}`, queryParams);
}

/**
 * GET /api/vns/list
 */
export async function get_api_vns_list(client: SdkClient, queryParams?: QueryParams): Promise<ResponseData> {
  return client.get(`/api/vns/list`, queryParams);
}

/**
 * GET /api/replication/status
 */
export async function get_api_replication_status(client: SdkClient, queryParams?: QueryParams): Promise<ResponseData> {
  return client.get(`/api/replication/status`, queryParams);
}

/**
 * POST /api/replication/on
 */
export async function post_api_replication_on(client: SdkClient, body?: RequestBody): Promise<ResponseData> {
  return client.post(`/api/replication/on`, body);
}

/**
 * POST /api/replication/off
 */
export async function post_api_replication_off(client: SdkClient, body?: RequestBody): Promise<ResponseData> {
  return client.post(`/api/replication/off`, body);
}

/**
 * POST /api/replication/autopin/local/off
 */
export async function post_api_replication_autopin_local_off(client: SdkClient, body?: RequestBody): Promise<ResponseData> {
  return client.post(`/api/replication/autopin/local/off`, body);
}

/**
 * POST /api/replication/autopin/local/on
 */
export async function post_api_replication_autopin_local_on(client: SdkClient, body?: RequestBody): Promise<ResponseData> {
  return client.post(`/api/replication/autopin/local/on`, body);
}

/**
 * POST /api/replication/autopin/remote/off
 */
export async function post_api_replication_autopin_remote_off(client: SdkClient, body?: RequestBody): Promise<ResponseData> {
  return client.post(`/api/replication/autopin/remote/off`, body);
}

/**
 * POST /api/replication/autopin/remote/on
 */
export async function post_api_replication_autopin_remote_on(client: SdkClient, body?: RequestBody): Promise<ResponseData> {
  return client.post(`/api/replication/autopin/remote/on`, body);
}

/**
 * GET /api/monitor/metrics
 */
export async function get_api_monitor_metrics(client: SdkClient, queryParams?: QueryParams): Promise<ResponseData> {
  return client.get(`/api/monitor/metrics`, queryParams);
}

/**
 * POST /api/rs/upload
 */
export async function post_api_rs_upload(client: SdkClient, body?: RequestBody): Promise<ResponseData> {
  return client.post(`/api/rs/upload`, body);
}

/**
 * GET /api/rs/recover/:id
 */
export async function get_api_rs_recover_Byid(id: string, client: SdkClient, queryParams?: QueryParams): Promise<ResponseData> {
  return client.get(`/api/rs/recover/${id}`, queryParams);
}

/**
 * POST /api/v/identity/register
 */
export async function post_api_v_identity_register(client: SdkClient, body?: RequestBody): Promise<ResponseData> {
  return client.post(`/api/v/identity/register`, body);
}

/**
 * POST /api/v/identity/rotate
 */
export async function post_api_v_identity_rotate(client: SdkClient, body?: RequestBody): Promise<ResponseData> {
  return client.post(`/api/v/identity/rotate`, body);
}

/**
 * GET /api/v/identity/:handle
 */
export async function get_api_v_identity_Byhandle(handle: string, client: SdkClient, queryParams?: QueryParams): Promise<ResponseData> {
  return client.get(`/api/v/identity/${handle}`, queryParams);
}

/**
 * POST /api/v/post
 */
export async function post_api_v_post(client: SdkClient, body?: RequestBody): Promise<ResponseData> {
  return client.post(`/api/v/post`, body);
}

/**
 * GET /api/v/allPosts
 */
export async function get_api_v_allPosts(client: SdkClient, queryParams?: QueryParams): Promise<ResponseData> {
  return client.get(`/api/v/allPosts`, queryParams);
}

/**
 * POST /api/v/follow/:targetHandle
 */
export async function post_api_v_follow_BytargetHandle(targetHandle: string, client: SdkClient, body?: RequestBody): Promise<ResponseData> {
  return client.post(`/api/v/follow/${targetHandle}`, body);
}

/**
 * GET /api/v/following
 */
export async function get_api_v_following(client: SdkClient, queryParams?: QueryParams): Promise<ResponseData> {
  return client.get(`/api/v/following`, queryParams);
}

/**
 * GET /api/v/timeline
 */
export async function get_api_v_timeline(client: SdkClient, queryParams?: QueryParams): Promise<ResponseData> {
  return client.get(`/api/v/timeline`, queryParams);
}

/**
 * GET /api/v/timeline/stream
 */
export async function get_api_v_timeline_stream(client: SdkClient, queryParams?: QueryParams): Promise<ResponseData> {
  return client.get(`/api/v/timeline/stream`, queryParams);
}

/**
 * GET /api/replicate/status
 */
export async function get_api_replicate_status(client: SdkClient, queryParams?: QueryParams): Promise<ResponseData> {
  return client.get(`/api/replicate/status`, queryParams);
}

/**
 * POST /api/replicate/override
 */
export async function post_api_replicate_override(client: SdkClient, body?: RequestBody): Promise<ResponseData> {
  return client.post(`/api/replicate/override`, body);
}

/**
 * GET /api/replicate/geo/status
 */
export async function get_api_replicate_geo_status(client: SdkClient, queryParams?: QueryParams): Promise<ResponseData> {
  return client.get(`/api/replicate/geo/status`, queryParams);
}

/**
 * POST /api/replicate/geo/on
 */
export async function post_api_replicate_geo_on(client: SdkClient, body?: RequestBody): Promise<ResponseData> {
  return client.post(`/api/replicate/geo/on`, body);
}

/**
 * POST /api/replicate/geo/off
 */
export async function post_api_replicate_geo_off(client: SdkClient, body?: RequestBody): Promise<ResponseData> {
  return client.post(`/api/replicate/geo/off`, body);
}

/**
 * GET /api/replicate/regions
 */
export async function get_api_replicate_regions(client: SdkClient, queryParams?: QueryParams): Promise<ResponseData> {
  return client.get(`/api/replicate/regions`, queryParams);
}

/**
 * POST /api/replicate/regions
 */
export async function post_api_replicate_regions(client: SdkClient, body?: RequestBody): Promise<ResponseData> {
  return client.post(`/api/replicate/regions`, body);
}

filename: packages/vinyl-peer-plugin-monitor/tsconfig.esm.json
filecontent:
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "module": "ESNext",                // produce ESM
    "target": "ES2020",                // or whatever target you prefer
    "outDir": "dist/esm",              // everything goes under dist/esm
    "declaration": true,               // emit .d.ts files
    "declarationDir": "dist/esm",      // put .d.ts next to .js
    "strict": true,
    "esModuleInterop": true,
    "moduleResolution": "node",
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}

filename: packages/vinyl-peer-plugin-monitor/package.json
filecontent:
{
  "name": "vinyl-peer-plugin-monitor",
  "version": "0.0.1",
  "authors": [
    "KDLabs"
  ],
  "type": "module",
  "main": "dist/cjs/index.js",
  "module": "dist/esm/index.js",
  "types": "dist/esm/index.d.ts",
  "exports": {
    "import": "./dist/esm/index.js",
    "require": "./dist/cjs/index.js"
  },
  "scripts": {
    "build:esm": "tsc -p tsconfig.esm.json",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build": "rimraf dist && npm run build:esm && npm run build:cjs",
    "test": "vitest"
  },
  "dependencies": {
    "express": "^4.18.2",
    "prom-client": "^15.1.3",
    "vinyl-peer-protocol": "workspace:*"
  },
  "devDependencies": {
    "@types/express": "^5.0.2",
    "@types/node": "^18.7.23",
    "typescript": "^5.7.3",
    "vitest": "^3.0.5"
  }
}

filename: packages/vinyl-peer-plugin-monitor/tsconfig.cjs.json
filecontent:
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "module": "CommonJS",     // produce CJS
    "target": "ES2020",       
    "outDir": "dist/cjs",     // everything goes under dist/cjs
    "declaration": false      // we don’t need .d.ts here (we already emitted them under dist/esm)
  },
  "include": ["src/**/*"]
}

filename: packages/vinyl-peer-plugin-monitor/src/MonitorPlugin.ts
filecontent:
import {
  BasePlugin,
  PluginCapabilities,
  PluginContext,
  VinylPeerPlugin,
  FileInfo,
} from "vinyl-peer-protocol";
import { Router, Request, Response } from "express";
import client from "prom-client";

export class MonitorPlugin extends BasePlugin implements VinylPeerPlugin {
  protected context!: PluginContext;

  // Prometheus registry & metrics
  private register!: client.Registry;
  private gaugePeersConnected!: client.Gauge<string>;
  private gaugeTotalPeers!: client.Gauge<string>;
  private gaugeFileCount!: client.Gauge<string>;
  private gaugePinnedFiles!: client.Gauge<string>;
  private counterUploadsTotal!: client.Counter<string>;
  private counterDownloadsTotal!: client.Counter<string>;
  private counterErrorsTotal!: client.Counter<string>;

  // Gauges for whether certain plugins are installed (1 = yes, 0 = no)
  private pluginGauges: Record<string, client.Gauge<string>> = {};

  // ← CHANGED: use NodeJS.Timeout so clearInterval() accepts it
  private updateInterval?: NodeJS.Timeout;

  getCapabilities(): PluginCapabilities {
    return {
      name: "vinyl-peer-plugin-monitor",
      version: "0.2.0",
      protocols: [],
      capabilities: ["monitoring"],
      permissions: {
        accessFiles: true, // iterate fileDb
        useNetwork: true, // read peer list
        modifyPeers: false,
        exposeHttp: true, // expose /metrics
      },
    };
  }

  async initialize(context: PluginContext): Promise<boolean> {
    const ok = await super.initialize(context);
    if (!ok) return false;
    this.context = context;

    // 1) Create a new Prometheus registry
    this.register = new client.Registry();
    client.collectDefaultMetrics({ register: this.register });

    // 2) Define Gauges and Counters
    this.gaugePeersConnected = new client.Gauge({
      name: "vinyl_peers_connected",
      help: "Number of currently connected peers",
      registers: [this.register],
    });
    this.gaugeTotalPeers = new client.Gauge({
      name: "vinyl_total_peers",
      help: "Total number of known peers",
      registers: [this.register],
    });
    this.gaugeFileCount = new client.Gauge({
      name: "vinyl_file_count",
      help: "Number of files indexed in LevelDB",
      registers: [this.register],
    });
    this.gaugePinnedFiles = new client.Gauge({
      name: "vinyl_pinned_files",
      help: "Number of files currently pinned",
      registers: [this.register],
    });

    this.counterUploadsTotal = new client.Counter({
      name: "vinyl_uploaded_files_total",
      help: "Total number of files uploaded",
      registers: [this.register],
    });
    this.counterDownloadsTotal = new client.Counter({
      name: "vinyl_downloaded_files_total",
      help: "Total number of files downloaded",
      registers: [this.register],
    });
    this.counterErrorsTotal = new client.Counter({
      name: "vinyl_errors_total",
      help: "Total number of error events we choose to count",
      registers: [this.register],
    });

    // 3) Hook into core‐provided upload/download callbacks instead of context.on(…)
    // Whenever PluginManager notifies of a file upload/download, these methods run:
    // → increment counters in onFileUploaded() / onFileDownloaded() below.

    // 4) Create “plugin installed” gauges based on whoever is already registered
    const installed = this.context.pluginManager.getAllPlugins();
    for (const p of installed) {
      const caps = p.getCapabilities();
      const name = caps.name;
      const g = new client.Gauge({
        name: `vinyl_plugin_installed_${sanitizeMetricName(name)}`,
        help: `1 if plugin "${name}" is installed, 0 otherwise`,
        registers: [this.register],
      });
      // Set to 1 at startup for each plugin that’s already there
      g.set(1);
      this.pluginGauges[name] = g;
    }

    // —— Removed any dynamic "pluginRegister" subscription, because PluginManager
    //     does NOT expose an event emitter. If you need runtime updates, you'd have
    //     to modify Vinyl/pluginManager to explicitly broadcast a "pluginRegister" event,
    //     but out of the box there is no getContextEmitter().

    return true;
  }

  async start(): Promise<void> {
    await super.start();

    // 5) Every 10s, refresh “connected peers,” “total peers,” “file count,” “pinned count”
    this.updateInterval = setInterval(async () => {
      try {
        // ● Peers
        const peersArray = Array.from(this.context.peers.values());
        const connectedPeers = peersArray.filter((p) => p.status === "connected");
        this.gaugePeersConnected.set(connectedPeers.length);
        this.gaugeTotalPeers.set(peersArray.length);

        // ● Files + pinned
        let fileCount = 0;
        let pinnedCount = 0;
        for await (const [, info] of this.context.fileDb.iterator()) {
          fileCount++;
          if ((info as any).pinned) pinnedCount++;
        }
        this.gaugeFileCount.set(fileCount);
        this.gaugePinnedFiles.set(pinnedCount);

        // ● Ensure “plugin installed” gauges stay at 1 for any plugin that exists today (no dynamic changes)
        const nowInstalled = this.context.pluginManager
          .getAllPlugins()
          .map((p) => p.getCapabilities().name);
        for (const name of Object.keys(this.pluginGauges)) {
          this.pluginGauges[name].set(nowInstalled.includes(name) ? 1 : 0);
        }
      } catch (err) {
        console.error("[MonitorPlugin] error updating gauges:", err);
        // If you’d like to count runtime errors, uncomment the next line:
        // this.counterErrorsTotal.inc();
      }
    }, 10_000);
  }

  async stop(): Promise<void> {
    if (this.updateInterval) {
      // clearInterval now accepts a NodeJS.Timeout
      clearInterval(this.updateInterval);
    }
    await super.stop();
  }

  setupProtocols(): void {
    // No custom libp2p protocols here
  }

  async handleProtocol(_p: string, _s: any, _peerId: string): Promise<void> {
    // Not used
  }

  /**
   * Called by PluginManager when a file upload completes.
   */
  onFileUploaded(_cid: string, _fileInfo: FileInfo): void {
    this.counterUploadsTotal.inc();
  }

  /**
   * Called by PluginManager when a file download completes.
   */
  onFileDownloaded(_cid: string): void {
    this.counterDownloadsTotal.inc();
  }

  getHttpNamespace(): string {
    return "/api/monitor";
  }

  getHttpRouter(): Router {
    const router = Router();

    // GET /api/monitor/metrics → expose Prometheus metrics
    router.get("/metrics", async (_req: Request, res: Response) => {
      try {
        res.setHeader("Content-Type", this.register.contentType);
        const metrics = await this.register.metrics();
        res.send(metrics);
      } catch (err: any) {
        console.error("[MonitorPlugin] /metrics error:", err);
        this.counterErrorsTotal.inc();
        res.status(500).send(err.message);
      }
    });

    return router;
  }
}

/**
 * Replace any invalid characters so that Prometheus‐style metric names stay valid.
 * E.g. "vinyl-peer-plugin-foo" → "vinyl_peer_plugin_foo"
 */
function sanitizeMetricName(name: string): string {
  return name.replace(/[^a-zA-Z0-9_]/g, "_");
}

filename: packages/vinyl-peer-plugin-monitor/src/index.ts
filecontent:
export * from "./MonitorPlugin.js";

filename: packages/vinyl-peer-plugin-sdk-generator/tsconfig.esm.json
filecontent:
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "module": "ESNext",                // produce ESM
    "target": "ES2020",                // or whatever target you prefer
    "outDir": "dist/esm",              // everything goes under dist/esm
    "declaration": true,               // emit .d.ts files
    "declarationDir": "dist/esm",      // put .d.ts next to .js
    "strict": true,
    "esModuleInterop": true,
    "moduleResolution": "node",
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}

filename: packages/vinyl-peer-plugin-sdk-generator/package.json
filecontent:
{
  "name": "vinyl-peer-plugin-sdk-generator",
  "version": "0.0.1",
  "authors": [
    "KDLabs"
  ],
  "type": "module",
  "main": "dist/cjs/index.js",
  "module": "dist/esm/index.js",
  "types": "dist/esm/index.d.ts",
  "exports": {
    "import": "./dist/esm/index.js",
    "require": "./dist/cjs/index.js"
  },
  "scripts": {
    "build:esm": "tsc -p tsconfig.esm.json",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build": "rimraf dist && npm run build:esm && npm run build:cjs",
    "test": "vitest"
  },
  "dependencies": {
    "express": "^5.1.0",
    "vinyl-peer-protocol": "workspace:*"
  },
  "devDependencies": {
    "@types/express": "^5.0.2",
    "@types/node": "^18.7.23",
    "rimraf": "^5.0.0",
    "typescript": "^5.7.3",
    "vitest": "^3.0.5"
  }
}

filename: packages/vinyl-peer-plugin-sdk-generator/tsconfig.cjs.json
filecontent:
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "module": "CommonJS",     // produce CJS
    "target": "ES2020",       
    "outDir": "dist/cjs",     // everything goes under dist/cjs
    "declaration": false      // we don’t need .d.ts here (we already emitted them under dist/esm)
  },
  "include": ["src/**/*"]
}

filename: packages/vinyl-peer-plugin-sdk-generator/src/index.ts
filecontent:
import { promises as fs } from "fs";
import path from "path";
import { Router } from "express";
import {
  BasePlugin,
  PluginCapabilities,
  PluginContext,
  VinylPeerPlugin,
} from "vinyl-peer-protocol";

interface EndpointInfo {
  method: string; // "GET" | "POST" | ...
  fullPath: string; // e.g. "/api/files/:cid"
  pathParams: string[]; // ["cid"] if path contains ":cid"
  hasQueryParams: boolean; // true for GET/DELETE
  hasBody: boolean; // true for POST/PUT/PATCH
}

interface SdkGeneratorOptions {
  outputDir?: string;
}

export class SdkGeneratorPlugin extends BasePlugin implements VinylPeerPlugin {
  protected context!: PluginContext;
  private options: Required<SdkGeneratorOptions>;

  constructor(options: SdkGeneratorOptions = {}) {
    super();
    this.options = {
      outputDir: options.outputDir ?? "generated-sdk",
    };
  }

  getCapabilities(): PluginCapabilities {
    return {
      name: "vinyl-peer-plugin-sdk-generator",
      version: "0.0.1",
      protocols: [],
      capabilities: ["sdk-generator"],
      permissions: {
        accessFiles: true,
        useNetwork: false,
        modifyPeers: false,
        exposeHttp: false,
      },
    };
  }

  async initialize(context: PluginContext): Promise<boolean> {
    const ok = await super.initialize(context);
    if (!ok) return false;
    this.context = context;
    return true;
  }

  /**
   * Once all plugins are registered and the HTTP server is up,
   * generate the SDK files.
   */
  async start(): Promise<void> {
    await super.start();

    // Wait until after Express has mounted all core/plugin routes
    // (e.g. after vinyl.startHttp() has been called in the main application).
    // A next‐tick delay ensures that `httpApp._router.stack` is “baked.”
    await new Promise((r) => process.nextTick(r));

    try {
      await this.generateSdkFiles();
      console.log(`[vinyl-sdk-generator] SDK written to "${this.options.outputDir}"`);
    } catch (err: any) {
      console.error("[vinyl-sdk-generator] Error generating SDK:", err);
    }
  }

  async stop(): Promise<void> {
    await super.stop();
  }

  setupProtocols(): void {
    // No libp2p protocols needed for SDK generation
  }

  async handleProtocol(_protocol: string, _stream: any, _peerId: string) {
    // Not used
  }

  getHttpNamespace(): string {
    return ""; // exposeHttp=false
  }
  getHttpRouter(): Router {
    return Router(); // never actually mounted
  }

  private async generateSdkFiles(): Promise<void> {
    // 1) Prepare output directory
    const outDir = path.isAbsolute(this.options.outputDir)
      ? this.options.outputDir
      : path.join(process.cwd(), this.options.outputDir);
    await fs.mkdir(outDir, { recursive: true });

    // 2) Collect all endpoints from core + plugins
    const endpoints: EndpointInfo[] = [];

    // Utility to walk an Express router stack
    const extract = (stack: any[], prefix = "") => {
      for (const layer of stack) {
        // a route “layer” has layer.route.path
        if (layer.route && layer.route.path) {
          const routePath: string = prefix + layer.route.path;
          Object.keys(layer.route.methods).forEach((m) => {
            if (!(layer.route.methods as any)[m]) return;
            const fullPath = routePath;
            const paramMatches = Array.from(fullPath.matchAll(/:([^\/]+)/g)).map(
              (match) => (match as RegExpMatchArray)[1],
            );
            endpoints.push({
              method: m.toUpperCase(),
              fullPath,
              pathParams: paramMatches,
              hasQueryParams: ["GET", "DELETE"].includes(m.toUpperCase()),
              hasBody: ["POST", "PUT", "PATCH"].includes(m.toUpperCase()),
            });
          });
        }
        // nested router (e.g. app.use("/foo", subRouter))
        else if (layer.handle?.stack && Array.isArray(layer.handle.stack)) {
          extract(layer.handle.stack, prefix);
        }
      }
    };

    // 2A) Core routes (registered by Vinyl.setupCoreRoutes)
    if (this.context.httpApp) {
      const coreStack = (this.context.httpApp as any)._router?.stack;
      if (Array.isArray(coreStack)) {
        extract(coreStack, "");
      }
    }

    // 2B) Plugin routes (each plugin.getHttpRouter())
    if (this.context.pluginManager) {
      for (const plugin of this.context.pluginManager.getAllPlugins()) {
        if (
          typeof (plugin as any).getHttpNamespace !== "function" ||
          typeof (plugin as any).getHttpRouter !== "function"
        ) {
          continue;
        }
        let namespace: string = (plugin as any).getHttpNamespace();
        if (!namespace.startsWith("/")) namespace = "/" + namespace;
        if (namespace.endsWith("/") && namespace.length > 1) {
          namespace = namespace.slice(0, -1);
        }
        const routerObj = (plugin as any).getHttpRouter();
        const subStack = (routerObj as any)._router?.stack ?? (routerObj as any).stack ?? [];
        extract(subStack, namespace);
      }
    }

    // 3) Write types.d.ts
    const typesDts = this.buildTypesDts();
    await fs.writeFile(path.join(outDir, "types.d.ts"), typesDts, "utf8");

    // 4) Write sdk.ts
    const sdkTs = this.buildSdkTs(endpoints);
    await fs.writeFile(path.join(outDir, "sdk.ts"), sdkTs, "utf8");
  }

  private buildTypesDts(): string {
    return `/**
 * AUTO‐GENERATED shared types for Vinyl SDK
 * Do not edit by hand.
 */

export type QueryParams = Record<string, any>;
export type RequestBody = any;
export type ResponseData = any;

export interface SdkClient {
  /**
   * Simple HTTP client with baseURL pointing to your Vinyl node.
   * e.g. const client = createSdkClient("http://localhost:3001")
   */
  get<T = ResponseData>(path: string, params?: QueryParams): Promise<T>;
  post<T = ResponseData>(path: string, body?: RequestBody, params?: QueryParams): Promise<T>;
  put<T = ResponseData>(path: string, body?: RequestBody, params?: QueryParams): Promise<T>;
  delete<T = ResponseData>(path: string, params?: QueryParams): Promise<T>;
}
`;
  }

  private buildSdkTs(endpoints: EndpointInfo[]): string {
    const lines: string[] = [];

    // Header + imports
    lines.push(`/**`);
    lines.push(` * AUTO‐GENERATED VINYL SDK`);
    lines.push(` * Do not edit by hand.`);
    lines.push(` */`);
    lines.push(``);
    lines.push(`import fetch from "node-fetch";`);
    lines.push(`import { SdkClient, QueryParams, RequestBody, ResponseData } from "./types";`);
    lines.push(``);

    // createSdkClient utility
    lines.push(`/**`);
    lines.push(` * Create a simple SdkClient using fetch`);
    lines.push(` */`);
    lines.push(`export function createSdkClient(baseURL: string): SdkClient {`);
    lines.push(`  return {`);
    lines.push(`    async get<T = ResponseData>(path: string, params?: QueryParams): Promise<T> {`);
    lines.push(`      const url = new URL(path, baseURL);`);
    lines.push(
      `      if (params) Object.entries(params).forEach(([k, v]) => url.searchParams.append(k, String(v)));`,
    );
    lines.push(`      const res = await fetch(url.toString(), { method: "GET" });`);
    lines.push(`      return res.json();`);
    lines.push(`    },`);
    lines.push(
      `    async post<T = ResponseData>(path: string, body?: RequestBody, params?: QueryParams): Promise<T> {`,
    );
    lines.push(`      const url = new URL(path, baseURL);`);
    lines.push(
      `      if (params) Object.entries(params).forEach(([k, v]) => url.searchParams.append(k, String(v)));`,
    );
    lines.push(`      const res = await fetch(url.toString(), {`);
    lines.push(`        method: "POST",`);
    lines.push(`        headers: { "Content-Type": "application/json" },`);
    lines.push(`        body: body ? JSON.stringify(body) : undefined`);
    lines.push(`      });`);
    lines.push(`      return res.json();`);
    lines.push(`    },`);
    lines.push(
      `    async put<T = ResponseData>(path: string, body?: RequestBody, params?: QueryParams): Promise<T> {`,
    );
    lines.push(`      const url = new URL(path, baseURL);`);
    lines.push(
      `      if (params) Object.entries(params).forEach(([k, v]) => url.searchParams.append(k, String(v)));`,
    );
    lines.push(`      const res = await fetch(url.toString(), {`);
    lines.push(`        method: "PUT",`);
    lines.push(`        headers: { "Content-Type": "application/json" },`);
    lines.push(`        body: body ? JSON.stringify(body) : undefined`);
    lines.push(`      });`);
    lines.push(`      return res.json();`);
    lines.push(`    },`);
    lines.push(
      `    async delete<T = ResponseData>(path: string, params?: QueryParams): Promise<T> {`,
    );
    lines.push(`      const url = new URL(path, baseURL);`);
    lines.push(
      `      if (params) Object.entries(params).forEach(([k, v]) => url.searchParams.append(k, String(v)));`,
    );
    lines.push(`      const res = await fetch(url.toString(), { method: "DELETE" });`);
    lines.push(`      return res.json();`);
    lines.push(`    }`);
    lines.push(`  };`);
    lines.push(`}`);
    lines.push(``);

    // Generate one function per endpoint
    endpoints.forEach((ep) => {
      // Build a safe function name
      const sanitized = ep.fullPath
        .replace(/^\/+/g, "")
        .replace(/\/+/g, "_")
        .replace(/:([^_]+)/g, "By$1")
        .replace(/[^a-zA-Z0-9_]/g, "");
      const fnName = `${ep.method.toLowerCase()}_${sanitized}`;

      // 1) Required path params
      const paramsList: string[] = [];
      ep.pathParams.forEach((p) => {
        paramsList.push(`${p}: string`);
      });

      // 2) Required client comes next
      paramsList.push(`client: SdkClient`);

      // 3) Optional query params (for GET/DELETE) or optional body (for POST/PUT/PATCH)
      if (ep.hasQueryParams) {
        paramsList.push(`queryParams?: QueryParams`);
      }
      if (ep.hasBody) {
        paramsList.push(`body?: RequestBody`);
      }

      // Write JSDoc
      lines.push(`/**`);
      lines.push(` * ${ep.method} ${ep.fullPath}`);
      lines.push(` */`);

      // Function signature
      lines.push(
        `export async function ${fnName}(${paramsList.join(", ")}): Promise<ResponseData> {`,
      );

      // Build the actual path expression (interpolating path params)
      const pathExpr = "`" + ep.fullPath.replace(/:([^\/]+)/g, "${$1}") + "`";

      // Decide invocation based on HTTP method
      if (["GET", "DELETE"].includes(ep.method)) {
        // GET/DELETE: client.get(path, queryParams)
        lines.push(
          `  return client.${ep.method.toLowerCase()}(${pathExpr}${
            ep.hasQueryParams ? ", queryParams" : ""
          });`,
        );
      } else {
        // POST/PUT/PATCH: client.post(path, body)
        lines.push(
          `  return client.${ep.method.toLowerCase()}(${pathExpr}, ${
            ep.hasBody ? "body" : "undefined"
          }${ep.hasQueryParams ? ", queryParams" : ""});`,
        );
      }

      lines.push(`}`);
      lines.push(``);
    });

    return lines.join("\n");
  }
}

filename: packages/vinyl-peer-plugin-name-service/tsconfig.esm.json
filecontent:
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "module": "ESNext",                // produce ESM
    "target": "ES2020",                // or whatever target you prefer
    "outDir": "dist/esm",              // everything goes under dist/esm
    "declaration": true,               // emit .d.ts files
    "declarationDir": "dist/esm",      // put .d.ts next to .js
    "strict": true,
    "esModuleInterop": true,
    "moduleResolution": "node",
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}

filename: packages/vinyl-peer-plugin-name-service/package.json
filecontent:
{
  "name": "vinyl-peer-plugin-nameservice",
  "version": "0.0.1",
  "authors": [
    "KDLabs"
  ],
  "type": "module",
  "main": "dist/cjs/index.js",
  "module": "dist/esm/index.js", 
  "types": "dist/esm/index.d.ts",
  "exports": {
    "import": "./dist/esm/index.js",
    "require": "./dist/cjs/index.js"
  },
  "scripts": {
    "build:esm": "tsc -p tsconfig.esm.json",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build": "rimraf dist && npm run build:esm && npm run build:cjs",
    "test": "vitest"
  },
  "dependencies": {
    "express": "^5.1.0",
    "level": "^10.0.0",
    "vinyl-peer-protocol": "workspace:*"
  },
  "devDependencies": {
    "@types/express": "^5.0.2",
    "@types/node": "^18.7.23",
    "typescript": "^5.7.3",
    "vitest": "^3.0.5"
  }
}

filename: packages/vinyl-peer-plugin-name-service/tsconfig.cjs.json
filecontent:
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "module": "CommonJS",     // produce CJS
    "target": "ES2020",       
    "outDir": "dist/cjs",     // everything goes under dist/cjs
    "declaration": false      // we don’t need .d.ts here (we already emitted them under dist/esm)
  },
  "include": ["src/**/*"]
}

filename: packages/vinyl-peer-plugin-name-service/src/NameServicePlugin.ts
filecontent:
import type { Request, Response, Router } from "express";
import {
  BasePlugin,
  PluginCapabilities,
  PluginContext,
  VinylPeerPlugin,
} from "vinyl-peer-protocol";
import { Level } from "level";
import express from "express";

/**
 * Vinyl Peer Name Service (VPNS) Plugin
 *
 * - Provides a decentralized mapping from human‐readable names → Peer IDs
 * - Registers and resolves names via HTTP endpoints
 * - Propagates name registrations over PubSub so peers keep their local DB in sync
 * - Supports listing all known name records
 */

export interface NameRecord {
  name: string; // e.g. "alice.vinyl"
  peerId: string; // libp2p PeerId string
  owner: string; // PeerId of the registrar
  createdAt: string; // ISO timestamp
  updatedAt: string; // ISO timestamp
}

export interface NameEvent {
  type: "register" | "update" | "delete";
  record: NameRecord;
}

export class NameServicePlugin extends BasePlugin implements VinylPeerPlugin {
  protected context!: PluginContext;
  private nameDb!: Level<string, NameRecord>;
  private readonly PUBSUB_TOPIC = "/vns/registry/1.0.0";

  getCapabilities(): PluginCapabilities {
    return {
      name: "vinyl-peer-plugin-nameservice",
      version: "0.0.1",
      protocols: [],
      capabilities: ["nameservice"],
      permissions: {
        accessFiles: false,
        useNetwork: true,
        modifyPeers: false,
        exposeHttp: true,
      },
    };
  }

  async initialize(context: PluginContext): Promise<boolean> {
    const ok = await super.initialize(context);
    if (!ok) return false;
    this.context = context;

    // Create a LevelDB under ./vns-records
    this.nameDb = new Level<string, NameRecord>("vns-records", { valueEncoding: "json" });

    return true;
  }

  async start(): Promise<void> {
    await super.start();

    // Subscribe to PubSub for name events
    const ps = (this.context.libp2p as any).pubsub ?? (this.context.libp2p as any).services?.pubsub;
    if (!ps) {
      throw new Error("VinylPeerNameServicePlugin: PubSub service not available");
    }

    await ps.subscribe(this.PUBSUB_TOPIC);
    ps.addEventListener("message", async (evt: any) => {
      const msg = new TextDecoder().decode(evt.detail.data);
      try {
        const event: NameEvent = JSON.parse(msg);
        const key = event.record.name;
        if (event.type === "register" || event.type === "update") {
          await this.nameDb.put(key, event.record);
        } else if (event.type === "delete") {
          await this.nameDb.del(key).catch(() => {});
        }
      } catch {
        // ignore malformed messages
      }
    });
  }

  async stop(): Promise<void> {
    await this.nameDb.close();
    await super.stop();
  }

  setupProtocols(): void {
    // No custom libp2p protocols needed (we use PubSub)
  }

  async handleProtocol(_protocol: string, _stream: any, _peerId: string): Promise<void> {
    // No custom protocol handlers
  }

  getHttpNamespace(): string {
    return "/api/vns";
  }

  getHttpRouter(): Router {
    const router = express.Router();
    router.use(express.json());

    // Register or update a name
    // POST /api/vns/register
    // Body: { name: string, peerId: string }
    router.post("/register", async (req: Request, res: Response) => {
      try {
        const { name, peerId } = req.body as { name: string; peerId: string };
        if (typeof name !== "string" || typeof peerId !== "string") {
          res.status(400).json({ error: "Invalid payload: name and peerId are required" });
          return;
        }

        // Check if name is already taken by a different owner
        const existing = await this.nameDb.get(name).catch(() => null);
        const now = new Date().toISOString();
        let record: NameRecord;

        if (!existing) {
          // New registration
          record = {
            name,
            peerId,
            owner: peerId,
            createdAt: now,
            updatedAt: now,
          };
        } else {
          // Only owner can update
          if (existing.owner !== peerId) {
            res.status(403).json({ error: "Name already registered by another peer" });
            return;
          }
          record = {
            ...existing,
            peerId,
            updatedAt: now,
          };
        }

        await this.nameDb.put(name, record);

        // Broadcast registration/update event
        const event: NameEvent = { type: existing ? "update" : "register", record };
        const ps =
          (this.context.libp2p as any).pubsub ?? (this.context.libp2p as any).services?.pubsub;
        await ps.publish(this.PUBSUB_TOPIC, new TextEncoder().encode(JSON.stringify(event)));

        res.json({ success: true, record });
      } catch (err: any) {
        res.status(500).json({ error: err.message });
      }
    });

    // Resolve a name to a PeerId
    // GET /api/vns/resolve/:name
    router.get("/resolve/:name", async (req: Request, res: Response) => {
      try {
        const name = req.params.name;
        const record = await this.nameDb.get(name).catch(() => null);
        if (!record) {
          res.status(404).json({ error: "Name not found" });
          return;
        }
        res.json({ peerId: record.peerId, record });
      } catch (err: any) {
        res.status(500).json({ error: err.message });
      }
    });

    // Delete a name (only owner allowed)
    // DELETE /api/vns/delete/:name
    // Body: { owner: string }
    router.delete("/delete/:name", async (req: Request, res: Response) => {
      try {
        const name = req.params.name;
        const { owner } = req.body as { owner: string };
        if (typeof owner !== "string") {
          res.status(400).json({ error: "Invalid payload: owner is required" });
          return;
        }
        const existing = await this.nameDb.get(name).catch(() => null);
        if (!existing) {
          res.status(404).json({ error: "Name not found" });
          return;
        }
        if (existing.owner !== owner) {
          res.status(403).json({ error: "Only the owner may delete this name" });
          return;
        }
        await this.nameDb.del(name);

        // Broadcast delete event
        const event: NameEvent = { type: "delete", record: existing };
        const ps =
          (this.context.libp2p as any).pubsub ?? (this.context.libp2p as any).services?.pubsub;
        await ps.publish(this.PUBSUB_TOPIC, new TextEncoder().encode(JSON.stringify(event)));

        res.json({ success: true });
      } catch (err: any) {
        res.status(500).json({ error: err.message });
      }
    });

    // List all name records
    // GET /api/vns/list
    router.get("/list", async (_req: Request, res: Response) => {
      try {
        const records: NameRecord[] = [];
        for await (const [, rec] of this.nameDb.iterator()) {
          records.push(rec);
        }
        res.json({ records });
      } catch (err: any) {
        res.status(500).json({ error: err.message });
      }
    });

    return router;
  }
}

filename: packages/vinyl-peer-plugin-name-service/src/index.ts
filecontent:
export * from "./NameServicePlugin.js";

filename: packages/vinyl-peer-plugin-replication/tsconfig.esm.json
filecontent:
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "module": "ESNext",                // produce ESM
    "target": "ES2020",                // or whatever target you prefer
    "outDir": "dist/esm",              // everything goes under dist/esm
    "declaration": true,               // emit .d.ts files
    "declarationDir": "dist/esm",      // put .d.ts next to .js
    "strict": true,
    "esModuleInterop": true,
    "moduleResolution": "node",
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}

filename: packages/vinyl-peer-plugin-replication/package.json
filecontent:
{
  "name": "vinyl-peer-plugin-replication",
  "version": "0.0.1",
  "authors": [
    "KDLabs"
  ],
  "type": "module",
  "main": "dist/cjs/index.js",
  "module": "dist/esm/index.js", 
  "types": "dist/esm/index.d.ts",
  "exports": {
    "import": "./dist/esm/index.js",
    "require": "./dist/cjs/index.js"
  },
  "scripts": {
    "build:esm": "tsc -p tsconfig.esm.json",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build": "rimraf dist && npm run build:esm && npm run build:cjs",
    "test": "vitest"
  },
  "dependencies": {
    "express": "^5.1.0",
    "vinyl-peer-protocol": "workspace:*"
  },
  "devDependencies": {
    "@types/express": "^5.0.2",
    "@types/node": "^18.7.23",
    "typescript": "^5.7.3",
    "vitest": "^3.0.5"
  }
}

filename: packages/vinyl-peer-plugin-replication/tsconfig.cjs.json
filecontent:
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "module": "CommonJS",     // produce CJS
    "target": "ES2020",       
    "outDir": "dist/cjs",     // everything goes under dist/cjs
    "declaration": false      // we don’t need .d.ts here (we already emitted them under dist/esm)
  },
  "include": ["src/**/*"]
}

filename: packages/vinyl-peer-plugin-replication/src/ReplicationPlugin.ts
filecontent:
import express, { Router } from "express";
import { BasePlugin } from "vinyl-peer-protocol";

export class ReplicationPlugin extends BasePlugin {
  private enabled: boolean;
  private autoPinLocal: boolean;
  private autoPinRemote: boolean;
  private TOPIC: string;
  protected context!: any;

  constructor(
    opts: {
      autoPinLocal?: boolean;
      autoPinRemote?: boolean;
      topic?: string;
    } = {},
  ) {
    super();
    this.enabled = true;
    this.autoPinLocal = opts.autoPinLocal ?? true;
    this.autoPinRemote = opts.autoPinRemote ?? true;
    this.TOPIC = opts.topic ?? "vinyl:replicate";
  }

  getCapabilities() {
    return {
      name: "vinyl-peer-plugin-replication",
      version: "0.0.1",
      protocols: [],
      capabilities: ["replication"],
      fileTypes: [],
      permissions: {
        accessFiles: true,
        useNetwork: true,
        modifyPeers: false,
        exposeHttp: true,
      },
    };
  }

  async initialize(context: any): Promise<boolean> {
    const ok = await super.initialize(context);
    if (!ok) return false;
    this.context = context;
    return true;
  }

  /**
   * Now that libp2p is started, we can safely subscribe to pubsub.
   */
  async start(): Promise<void> {
    await super.start();

    if (this.autoPinRemote) {
      try {
        const pubsub = this.context.libp2p.services.pubsub;
        if (!pubsub) {
          throw new Error("ReplicationPlugin: pubsub service is not available on libp2p");
        }

        // Subscribe to the replication topic
        await pubsub.subscribe(this.TOPIC);
        pubsub.addEventListener("message", (evt: any) => {
          if (evt.detail.topic !== this.TOPIC) return;

          try {
            const msg = JSON.parse(new TextDecoder().decode(evt.detail.data));
            if (msg.type === "replicate" && this.enabled) {
              const cid = msg.cid as string;
              // If we don’t already have this file locally, pin it
              if (!this.context.files.has(cid)) {
                this.context.pinFile(cid).catch((err: any) => {
                  console.error(`ReplicationPlugin: failed to pin ${cid}:`, err);
                });
              }
            }
          } catch {
            // Ignore invalid JSON
          }
        });
      } catch (err) {
        console.error("ReplicationPlugin: kon niet subscriben op replication topic:", err);
      }
    }
  }

  async stop(): Promise<void> {
    this.enabled = false;
    await super.stop();
  }

  setupProtocols(): void {
    // no custom libp2p-protocols here
  }

  async handleProtocol(protocol: string, stream: any, peerId: string) {
    // no custom protocol handler
  }

  onFileDownloaded(cid: string): void {
    // If autoPinLocal is on, pin locally
    if (this.autoPinLocal && this.enabled) {
      this.context
        .pinFile(cid)
        .then(() => console.log(`ReplicationPlugin: automatisch gepinned "${cid}".`))
        .catch((err: any) => console.error(`ReplicationPlugin: kon niet pinnen "${cid}":`, err));
    }

    // If autoPinRemote is on, broadcast to peers so they can pin as well
    if (this.autoPinRemote && this.enabled) {
      const pubsub = this.context.libp2p.services.pubsub;
      if (!pubsub) {
        console.error("ReplicationPlugin: pubsub service unavailable when broadcasting");
        return;
      }

      const payload = JSON.stringify({ type: "replicate", cid });
      pubsub
        .publish(this.TOPIC, new TextEncoder().encode(payload))
        .catch((e: any) => console.error("ReplicationPlugin: pubsub error:", e));
    }
  }

  getHttpNamespace(): string {
    return "/api/replication";
  }

  getHttpRouter(): Router {
    const router = express.Router();

    router.get("/status", (_req, res) => {
      res.json({
        enabled: this.enabled,
        autoPinLocal: this.autoPinLocal,
        autoPinRemote: this.autoPinRemote,
      });
    });

    router.post("/on", (_req, res) => {
      this.enabled = true;
      res.json({ enabled: true, message: "Auto-replication is now ON." });
    });

    router.post("/off", (_req, res) => {
      this.enabled = false;
      res.json({ enabled: false, message: "Auto-replication is now OFF." });
    });

    router.post("/autopin/local/off", (_req, res) => {
      this.autoPinLocal = false;
      res.json({ enabled: this.autoPinLocal, message: "Auto-pinning local is now OFF." });
    });

    router.post("/autopin/local/on", (_req, res) => {
      this.autoPinLocal = true;
      res.json({ enabled: this.autoPinLocal, message: "Auto-pinning local is now ON." });
    });

    router.post("/autopin/remote/off", (_req, res) => {
      this.autoPinRemote = false;
      res.json({ enabled: this.autoPinRemote, message: "Auto-pinning remote is now OFF." });
    });

    router.post("/autopin/remote/on", (_req, res) => {
      this.autoPinRemote = true;
      res.json({ enabled: this.autoPinRemote, message: "Auto-pinning remote is now ON." });
    });

    return router;
  }
}

filename: packages/vinyl-peer-plugin-replication/src/index.ts
filecontent:
export * from "./ReplicationPlugin.js";

filename: packages/vinyl-peer-plugin-v/tsconfig.esm.json
filecontent:
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "module": "ESNext",                // produce ESM
    "target": "ES2020",                // or whatever target you prefer
    "outDir": "dist/esm",              // everything goes under dist/esm
    "declaration": true,               // emit .d.ts files
    "declarationDir": "dist/esm",      // put .d.ts next to .js
    "strict": true,
    "esModuleInterop": true,
    "moduleResolution": "node",
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}

filename: packages/vinyl-peer-plugin-v/package.json
filecontent:
{
  "name": "vinyl-peer-plugin-v",
  "version": "0.0.1",
  "authors": [
    "KDLabs"
  ],
  "type": "module",
  "module": "dist/esm/index.js",
  "types": "dist/esm/index.d.ts",
  "exports": {
    "import": "./dist/esm/index.js"
  },
  "scripts": {
    "build:esm": "tsc -p tsconfig.esm.json",
    "build": "rimraf dist && npm run build:esm",
    "test": "vitest"
  },
  "dependencies": {
    "express": "^5.1.0",
    "level": "^10.0.0",
    "libp2p-crypto": "^0.21.2",
    "multiformats": "^13.3.6",
    "uuid": "^11.1.0",
    "vinyl-peer-protocol": "workspace:*"
  },
  "devDependencies": {
    "@types/express": "^5.0.2",
    "@types/node": "^18.7.23",
    "rimraf": "^5.0.0",
    "typescript": "^5.7.3",
    "vitest": "^3.0.5"
  }
}

filename: packages/vinyl-peer-plugin-v/tsconfig.cjs.json
filecontent:
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "module": "CommonJS",     // produce CJS
    "target": "ES2020",       
    "outDir": "dist/cjs",     // everything goes under dist/cjs
    "declaration": false      // we don’t need .d.ts here (we already emitted them under dist/esm)
  },
  "include": ["src/**/*"]
}

filename: packages/vinyl-peer-plugin-v/src/VPlugin.ts
filecontent:
import type { Request, Response, Router } from "express";
import {
  BasePlugin,
  PluginContext,
  VinylPeerPlugin,
  PluginCapabilities,
} from "vinyl-peer-protocol";
import { Level } from "level";
import express from "express";
import { v4 as uuidv4 } from "uuid";
import { sha256 } from "multiformats/hashes/sha2";
import crypto from "libp2p-crypto";

import type {
  MicroPost,
  CommentRecord,
  LikeRecord,
  PollRecord,
  VoteRecord,
  NewCommentEvent,
  NewLikeEvent,
  NewPollEvent,
  NewPostEvent,
  NewVoteEvent,
  IdentityRecord,
  FollowPubEvent,
  BanPubEvent,
  PollOption,
} from "./types.js";

/**
 * ─────────────────────────────────────────────────────────────────────────────
 *   Authentication Helpers
 * ─────────────────────────────────────────────────────────────────────────────
 */

/**
 * Canonicalize a JSON object by lexicographically sorting keys.
 * Used to build a consistent string for signing / verifying.
 */
function canonicalize(obj: any): string {
  if (Array.isArray(obj)) {
    return `[${obj.map(canonicalize).join(",")}]`;
  }
  if (obj && typeof obj === "object") {
    const keys = Object.keys(obj).sort();
    return `{${keys.map((k) => `"${k}":${canonicalize(obj[k])}`).join(",")}}`;
  }
  return JSON.stringify(obj);
}

/**
 * Verify an Ed25519 signature given publicKey bytes, message hash, and base64 signature.
 */
async function verifySignature(
  publicKeyBytes: Uint8Array,
  message: Uint8Array,
  sigBase64: string,
): Promise<boolean> {
  const signature = Buffer.from(sigBase64, "base64");
  const publicKey = await crypto.keys.unmarshalPublicKey(publicKeyBytes);
  return publicKey.verify(message, signature);
}

/**
 * Middleware that enforces two-layer authentication on every request:
 *   1. User‐level: x-peer-id + x-signature over JSON body + timestamp check.
 *   2. App‐level:  x-app-id + x-app-signature over JSON body + timestamp check.
 *
 * After validation, sets `req.peerId`, `req.handle` and `req.appId` on the request object.
 */
function createAuthMiddleware(context: PluginContext, identityDb: Level<string, IdentityRecord>) {
  return async function auth(
    req: Request & { peerId?: string; handle?: string; appId?: string },
    res: Response,
    next: any,
  ) {
    try {
      // ─── 1) App‐level headers ─────────────────────────────────────────────────
      const appId = req.header("x-app-id");
      const appSig = req.header("x-app-signature");
      if (!appId || !appSig) {
        return res.status(401).json({ error: "Missing x-app-id or x-app-signature" });
      }
      // App payload for signature: JSON‐stringify(req.body + timestamp), same canonicalization
      const appPayload = req.body;
      if (!appPayload.timestamp) {
        return res.status(400).json({ error: "Missing timestamp in request body" });
      }
      const ts = Date.parse(appPayload.timestamp);
      if (Number.isNaN(ts) || Math.abs(Date.now() - ts) > 2 * 60_000) {
        return res.status(401).json({ error: "App timestamp out of range" });
      }
      // Look up App's registered public key in a fictional "appIdentityDb"
      // (for demonstration, we assume identityDb also stores AppRecords keyed by "app:<appId>")
      let appRecord: IdentityRecord;
      try {
        appRecord = await identityDb.get(`app:${appId}`);
      } catch {
        return res.status(401).json({ error: "Unknown or unregistered appId" });
      }
      const appPubBytes = Buffer.from(appRecord.currentPeerId, "utf-8"); // in reality you'd store actual publicKey bytes
      // (here we assume currentPeerId field was overloaded to hold base64 publicKey—adjust as needed)
      const appCanon = canonicalize({
        appId: appRecord.handle,
        timestamp: appPayload.timestamp,
      });
      const appHash = await sha256.digest(new TextEncoder().encode(appCanon));
      const appOK = await verifySignature(appPubBytes, appHash.bytes, appSig);
      if (!appOK) {
        return res.status(401).json({ error: "App signature invalid" });
      }

      // ─── 2) User‐level headers ─────────────────────────────────────────────────
      const peerIdStr = req.header("x-peer-id");
      const sigBase64 = req.header("x-signature");
      if (!peerIdStr || !sigBase64) {
        return res.status(401).json({ error: "Missing x-peer-id or x-signature" });
      }
      // Validate same timestamp again
      // Re‐canonicalize request body
      const payloadStr = JSON.stringify(req.body);
      const payloadHash = await sha256.digest(new TextEncoder().encode(payloadStr));
      // Fetch peer’s public key from peerStore
      let peerPubBytes: Uint8Array;
      try {
        const peerRecord = await context.libp2p.peerStore.get(peerIdStr as any);
        if (!peerRecord || !peerRecord.publicKey) {
          throw new Error("No public key");
        }
        peerPubBytes = (peerRecord.publicKey as any).bytes;
      } catch {
        return res.status(401).json({ error: "Unknown peerId or no public key" });
      }
      const sigOK = await verifySignature(peerPubBytes, payloadHash.bytes, sigBase64);
      if (!sigOK) {
        return res.status(401).json({ error: "User signature invalid" });
      }

      // ─── 3) Map peerId → handle ─────────────────────────────────────────────────
      let matchedHandle: string | null = null;
      for await (const [handle, rec] of identityDb.iterator()) {
        if (rec.currentPeerId === peerIdStr || rec.previousPeerIds.includes(peerIdStr)) {
          matchedHandle = handle;
          break;
        }
      }
      if (!matchedHandle) {
        return res.status(401).json({ error: "Unregistered or revoked peerId" });
      }

      // ─── 4) All good: attach to request ───────────────────────────────────────
      req.peerId = peerIdStr;
      req.handle = matchedHandle;
      req.appId = appId!;
      return next();
    } catch (err: any) {
      res.status(500).json({ error: err.message });
      return;
    }
  };
}

/**
 * ─────────────────────────────────────────────────────────────────────────────
 *   VPlugin Implementation (now with Comments/Likes/Dislikes/Polls/Friends/Bans)
 * ─────────────────────────────────────────────────────────────────────────────
 */
export class VPlugin extends BasePlugin implements VinylPeerPlugin {
  protected context!: PluginContext;

  // Per‐app (appId) LevelDB instances:
  private postDb!: Level<string, MicroPost>; // v-posts-<appId>
  private commentDb!: Level<string, CommentRecord>; // v-comments-<appId>
  private likeDb!: Level<string, LikeRecord>; // v-likes-<appId>      keyed by "<postId>::<handle>"
  private pollDb!: Level<string, PollRecord>; // v-polls-<appId>
  private voteDb!: Level<string, VoteRecord>; // v-votes-<appId>      keyed by "<pollId>::<handle>"
  private followDb!: Level<string, string[]>; // v-follows-<appId>
  private banDb!: Level<string, string[]>; // v-bans-<appId>       keyed by "<actor>" → array of banned handles
  private identityDb!: Level<string, IdentityRecord>; // v-identities-<appId> keyed by "handle" → record

  getCapabilities(): PluginCapabilities {
    return {
      name: "vinyl-peer-plugin-v",
      version: "0.0.2",
      protocols: [],
      capabilities: ["microblog", "identity", "social", "polls", "bans"],
      permissions: {
        accessFiles: false,
        useNetwork: true,
        modifyPeers: false,
        exposeHttp: true,
      },
    };
  }

  /**
   * Initialize: open or create all per‐app LevelDBs.
   */
  async initialize(context: PluginContext): Promise<boolean> {
    const ok = await super.initialize(context);
    if (!ok) return false;
    this.context = context;

    const appId = (context as any).appId as string;
    if (!appId) throw new Error("VPlugin: missing appId in PluginContext");

    // Each DB is namespaced by appId suffix:
    this.postDb = new Level<string, MicroPost>(`v-posts-${appId}`, { valueEncoding: "json" });
    this.commentDb = new Level<string, CommentRecord>(`v-comments-${appId}`, {
      valueEncoding: "json",
    });
    this.likeDb = new Level<string, LikeRecord>(`v-likes-${appId}`, { valueEncoding: "json" });
    this.pollDb = new Level<string, PollRecord>(`v-polls-${appId}`, { valueEncoding: "json" });
    this.voteDb = new Level<string, VoteRecord>(`v-votes-${appId}`, { valueEncoding: "json" });
    this.followDb = new Level<string, string[]>(`v-follows-${appId}`, { valueEncoding: "json" });
    this.banDb = new Level<string, string[]>(`v-bans-${appId}`, { valueEncoding: "json" });
    this.identityDb = new Level<string, IdentityRecord>(`v-identities-${appId}`, {
      valueEncoding: "json",
    });

    return true;
  }

  async start(): Promise<void> {
    await super.start();

    // Subscribe to all relevant PubSub topics for this appId:
    const appId = (this.context as any).appId as string;
    const ps = (this.context.libp2p as any).pubsub ?? (this.context.libp2p as any).services?.pubsub;
    if (!ps) {
      throw new Error("VPlugin: PubSub service not available");
    }

    const topics = [
      `/v/posts/${appId}/1.0.0`,
      `/v/comments/${appId}/1.0.0`,
      `/v/likes/${appId}/1.0.0`,
      `/v/polls/${appId}/1.0.0`,
      `/v/votes/${appId}/1.0.0`,
      `/v/follows/${appId}/1.0.0`,
      `/v/bans/${appId}/1.0.0`,
    ];
    for (const t of topics) {
      await ps.subscribe(t);
    }

    // Any incoming PubSub messages get written into the local DB (unless we already have them)
    ps.addEventListener("message", async (evt: any) => {
      const { topic, data } = evt.detail;
      const msg = new TextDecoder().decode(data);
      try {
        if (topic === `/v/posts/${appId}/1.0.0`) {
          const event = JSON.parse(msg) as NewPostEvent;
          const exists = await this.postDb.get(event.post.postId).catch(() => null);
          if (!exists) {
            await this.postDb.put(event.post.postId, event.post);
          }
        } else if (topic === `/v/comments/${appId}/1.0.0`) {
          const event = JSON.parse(msg) as NewCommentEvent;
          const exists = await this.commentDb.get(event.comment.commentId).catch(() => null);
          if (!exists) {
            await this.commentDb.put(event.comment.commentId, event.comment);
          }
        } else if (topic === `/v/likes/${appId}/1.0.0`) {
          const event = JSON.parse(msg) as NewLikeEvent;
          const key = `${event.like.postId}::${event.like.handle}`;
          await this.likeDb.put(key, event.like);
        } else if (topic === `/v/polls/${appId}/1.0.0`) {
          const event = JSON.parse(msg) as NewPollEvent;
          await this.pollDb.put(event.poll.pollId, event.poll);
        } else if (topic === `/v/votes/${appId}/1.0.0`) {
          const event = JSON.parse(msg) as NewVoteEvent;
          const key = `${event.vote.pollId}::${event.vote.handle}`;
          await this.voteDb.put(key, event.vote);
        } else if (topic === `/v/follows/${appId}/1.0.0`) {
          const event = JSON.parse(msg) as FollowPubEvent;
          const current = await this.followDb.get(event.from).catch(() => [] as string[]);
          if (event.type === "follow" && !current.includes(event.to)) {
            current.push(event.to);
            await this.followDb.put(event.from, current);
          } else if (event.type === "unfollow" && current.includes(event.to)) {
            const updated = current.filter((x) => x !== event.to);
            await this.followDb.put(event.from, updated);
          }
        } else if (topic === `/v/bans/${appId}/1.0.0`) {
          const event = JSON.parse(msg) as BanPubEvent;
          const current = await this.banDb.get(event.actor).catch(() => [] as string[]);
          if (!current.includes(event.target)) {
            current.push(event.target);
            await this.banDb.put(event.actor, current);
          }
        }
      } catch {
        // ignore malformed messages
      }
    });
  }

  async stop(): Promise<void> {
    await this.postDb.close();
    await this.commentDb.close();
    await this.likeDb.close();
    await this.pollDb.close();
    await this.voteDb.close();
    await this.followDb.close();
    await this.banDb.close();
    await this.identityDb.close();
    await super.stop();
  }

  setupProtocols(): void {
    // No custom libp2p protocols; we rely on PubSub instead.
  }

  async handleProtocol(_protocol: string, _stream: any, _peerId: string): Promise<void> {
    // None
  }

  /**
   * HTTP namespace will be `/api/v`
   * (the appId is included via headers, so we mount once and read x-app-id each time)
   */
  getHttpNamespace(): string {
    return "/api/v";
  }

  getHttpRouter(): Router {
    const router = express.Router();
    router.use(express.json());

    // Create an auth middleware bound to this plugin’s identityDb:
    const auth = createAuthMiddleware(this.context, this.identityDb);
    router.use(auth);

    // ────────────────────────────────────────────────────────────────────────────
    //   Identity (register / rotate / lookup)
    // ────────────────────────────────────────────────────────────────────────────

    /** POST /api/v/identity/register
     *  {
     *    handle, currentPeerId, previousPeerIds, createdAt, sig
     *  }
     */
    router.post("/identity/register", async (req: Request, res: Response) => {
      try {
        const rec = req.body as IdentityRecord;
        // Ensure handle is free:
        try {
          await this.identityDb.get(rec.handle);
          res.status(409).json({ error: "Handle already exists" });
          return;
        } catch {
          // OK, does not exist yet.
        }
        // Verify rec.sig over canonicalized {handle, currentPeerId, previousPeerIds, createdAt}
        const pay = {
          handle: rec.handle,
          currentPeerId: rec.currentPeerId,
          previousPeerIds: rec.previousPeerIds,
          createdAt: rec.createdAt,
        };
        const canon = canonicalize(pay);
        const hash = await sha256.digest(new TextEncoder().encode(canon));
        // Lookup public key of rec.currentPeerId in peerStore:
        const peerRec = await this.context.libp2p.peerStore.get(rec.currentPeerId as any);
        if (!peerRec || !peerRec.publicKey) {
          throw new Error("No public key for given peerId");
        }
        const pubBytes = (peerRec.publicKey as any).bytes;
        const ok = await verifySignature(pubBytes, hash.bytes, rec.sig);
        if (!ok) {
          res.status(401).json({ error: "Signature invalid" });
          return;
        }
        // Store
        await this.identityDb.put(rec.handle, rec);
        res.json({ success: true, handle: rec.handle });
      } catch (err: any) {
        res.status(500).json({ error: err.message });
        return;
      }
    });

    /** POST /api/v/identity/rotate
     *  {
     *    handle, currentPeerId, previousPeerIds, createdAt, sig
     *  }
     */
    router.post("/identity/rotate", async (req: Request, res: Response) => {
      try {
        const rec = req.body as IdentityRecord;
        // Fetch existing:
        let existing: IdentityRecord;
        try {
          existing = await this.identityDb.get(rec.handle);
        } catch {
          res.status(404).json({ error: "No such identity to rotate" });
          return;
        }
        // Only existing.currentPeerId may rotate:
        if ((req as Request & { peerId?: string }).peerId !== existing.currentPeerId) {
          res.status(403).json({ error: "Not authorized to rotate" });
          return;
        }
        // Verify rec.sig signed by old key:
        const payload = {
          handle: rec.handle,
          currentPeerId: rec.currentPeerId,
          previousPeerIds: rec.previousPeerIds,
          createdAt: rec.createdAt,
        };
        const canon = canonicalize(payload);
        const hash = await sha256.digest(new TextEncoder().encode(canon));
        const oldPeerRec = await this.context.libp2p.peerStore.get(existing.currentPeerId as any);
        if (!oldPeerRec || !oldPeerRec.publicKey) {
          throw new Error("No public key for old PeerId");
        }
        const oldPubBytes = (oldPeerRec.publicKey as any).bytes;
        const ok = await verifySignature(oldPubBytes, hash.bytes, rec.sig);
        if (!ok) {
          res.status(401).json({ error: "Rotation signature invalid" });
          return;
        }
        // Persist:
        await this.identityDb.put(rec.handle, rec);
        res.json({ success: true, handle: rec.handle, newPeerId: rec.currentPeerId });
        return;
      } catch (err: any) {
        res.status(500).json({ error: err.message });
        return;
      }
    });

    /** GET /api/v/identity/:handle */
    router.get("/identity/:handle", async (req: Request, res: Response) => {
      try {
        const rec = await this.identityDb.get(req.params.handle);
        res.json(rec);
        return;
      } catch {
        res.status(404).json({ error: "Identity not found" });
        return;
      }
    });

    // ────────────────────────────────────────────────────────────────────────────
    //   Post Routes (Create / Read)
    // ────────────────────────────────────────────────────────────────────────────

    /** POST /api/v/post
     *  {
     *    text, timestamp
     *  }
     */
    router.post("/post", async (req: Request, res: Response) => {
      try {
        const handle = (req as Request & { handle?: string }).handle!;
        const peerId = (req as Request & { peerId?: string }).peerId!;
        const appId = (req as Request & { appId?: string }).appId!;
        const text: string = req.body.text;
        const timestamp: string = req.body.timestamp;

        // Check length (if not a poll reference):
        if (!req.body.isPoll && (!text || text.length > 280)) {
          res.status(400).json({ error: "Text must be 1–280 characters" });
          return;
        }

        // Construct MicroPost:
        const postId = `${handle}-${Date.now()}-${uuidv4()}`;
        const post: MicroPost = {
          postId,
          author: handle,
          peerId,
          text,
          createdAt: timestamp,
          isPoll: req.body.isPoll ?? false,
        };

        // Save locally then broadcast via PubSub:
        await this.postDb.put(postId, post);
        const event: NewPostEvent = { type: "newPost", post };
        const ps =
          (this.context.libp2p as any).pubsub ?? (this.context.libp2p as any).services?.pubsub;
        await ps.publish(
          `/v/posts/${appId}/1.0.0`,
          new TextEncoder().encode(JSON.stringify(event)),
        );

        res.json({ success: true, postId });
        return;
      } catch (err: any) {
        res.status(500).json({ error: err.message });
        return;
      }
    });

    /** GET /api/v/posts/:postId → fetch a single post */
    router.get("/posts/:postId", async (req: Request, res: Response) => {
      try {
        const post = await this.postDb.get(req.params.postId);
        res.json(post);
        return;
      } catch {
        res.status(404).json({ error: "Post not found" });
        return;
      }
    });

    /** GET /api/v/allPosts → fetch all posts sorted desc by createdAt */
    router.get("/allPosts", async (_req: Request, res: Response) => {
      try {
        const arr: MicroPost[] = [];
        for await (const [, p] of this.postDb.iterator()) {
          arr.push(p);
        }
        arr.sort((a, b) => (a.createdAt > b.createdAt ? -1 : 1));
        res.json({ posts: arr });
        return;
      } catch (err: any) {
        res.status(500).json({ error: err.message });
        return;
      }
    });

    // ────────────────────────────────────────────────────────────────────────────
    //   Comment Routes
    // ────────────────────────────────────────────────────────────────────────────

    /** POST /api/v/comment
     *  {
     *    postId, text, timestamp
     *  }
     */
    router.post("/comment", async (req: Request, res: Response) => {
      try {
        const handle = (req as Request & { handle?: string }).handle!;
        const peerId = (req as Request & { peerId?: string }).peerId!;
        const appId = (req as Request & { appId?: string }).appId!;
        const postId: string = req.body.postId;
        const text: string = req.body.text;
        const timestamp: string = req.body.timestamp;

        if (!text || text.length > 280) {
          res.status(400).json({ error: "Comment must be 1–280 characters" });
          return;
        }
        // Ensure post exists:
        const exists = await this.postDb.get(postId).catch(() => null);
        if (!exists) {
          res.status(404).json({ error: "Post not found" });
          return;
        }
        // Check if commenter is banned by post author or by app:
        const author = exists.author;
        const authorBans: string[] = await this.banDb.get(author).catch(() => [] as string[]);
        if (authorBans.includes(handle)) {
          res.status(403).json({ error: "You are banned from commenting on this user’s posts." });
          return;
        }
        // Create comment:
        const commentId = `${postId}-comment-${uuidv4()}`;
        const comment: CommentRecord = {
          commentId,
          postId,
          author: handle,
          peerId,
          text,
          createdAt: timestamp,
        };
        await this.commentDb.put(commentId, comment);
        // Broadcast via PubSub:
        const event: NewCommentEvent = { type: "newComment", comment };
        const ps =
          (this.context.libp2p as any).pubsub ?? (this.context.libp2p as any).services?.pubsub;
        await ps.publish(
          `/v/comments/${appId}/1.0.0`,
          new TextEncoder().encode(JSON.stringify(event)),
        );
        res.json({ success: true, commentId });
        return;
      } catch (err: any) {
        res.status(500).json({ error: err.message });
        return;
      }
    });

    /** GET /api/v/comments/:postId → fetch all comments for a post, sorted asc */
    router.get("/comments/:postId", async (req: Request, res: Response) => {
      try {
        const postId = req.params.postId;
        const arr: CommentRecord[] = [];
        for await (const [, c] of this.commentDb.iterator()) {
          if (c.postId === postId) arr.push(c);
        }
        arr.sort((a, b) => (a.createdAt < b.createdAt ? -1 : 1));
        res.json({ comments: arr });
        return;
      } catch (err: any) {
        res.status(500).json({ error: err.message });
        return;
      }
    });

    // ────────────────────────────────────────────────────────────────────────────
    //   Like / Dislike Routes
    // ────────────────────────────────────────────────────────────────────────────

    /** POST /api/v/like
     *  {
     *    postId, isLike (true/false), timestamp
     *  }
     */
    router.post("/like", async (req: Request, res: Response) => {
      try {
        const handle = (req as Request & { handle?: string }).handle!;
        const peerId = (req as Request & { peerId?: string }).peerId!;
        const appId = (req as Request & { appId?: string }).appId!;
        const postId: string = req.body.postId;
        const isLike: boolean = req.body.isLike;
        const timestamp: string = req.body.timestamp;

        // Ensure post exists:
        const exists = await this.postDb.get(postId).catch(() => null);
        if (!exists) {
          res.status(404).json({ error: "Post not found" });
          return;
        }
        // Check if user is banned by post author
        const author = exists.author;
        const authorBans: string[] = await this.banDb.get(author).catch(() => [] as string[]);
        if (authorBans.includes(handle)) {
          res
            .status(403)
            .json({ error: "You are banned from interacting with this user’s posts." });
          return;
        }
        // Upsert LikeRecord:
        const key = `${postId}::${handle}`;
        const record: LikeRecord = {
          postId,
          handle,
          peerId,
          isLike,
          createdAt: timestamp,
        };
        await this.likeDb.put(key, record);

        // Broadcast via PubSub:
        const event: NewLikeEvent = { type: "newLike", like: record };
        const ps =
          (this.context.libp2p as any).pubsub ?? (this.context.libp2p as any).services?.pubsub;
        await ps.publish(
          `/v/likes/${appId}/1.0.0`,
          new TextEncoder().encode(JSON.stringify(event)),
        );

        res.json({ success: true });
        return;
      } catch (err: any) {
        res.status(500).json({ error: err.message });
        return;
      }
    });

    /** GET /api/v/likes/:postId → fetch like/dislike counts for a post */
    router.get("/likes/:postId", async (req: Request, res: Response) => {
      try {
        const postId = req.params.postId;
        let likes = 0;
        let dislikes = 0;
        for await (const [, rec] of this.likeDb.iterator()) {
          if (rec.postId === postId) {
            if (rec.isLike) likes++;
            else dislikes++;
          }
        }
        res.json({ postId, likes, dislikes });
        return;
      } catch (err: any) {
        res.status(500).json({ error: err.message });
        return;
      }
    });

    // ────────────────────────────────────────────────────────────────────────────
    //   Poll Routes
    // ────────────────────────────────────────────────────────────────────────────

    /** POST /api/v/poll
     *  {
     *    postId, question, options: [string], timestamp, expiresAt?
     *  }
     */
    router.post("/poll", async (req: Request, res: Response) => {
      try {
        const handle = (req as Request & { handle?: string }).handle!;
        const peerId = (req as Request & { peerId?: string }).peerId!;
        const appId = (req as Request & { appId?: string }).appId!;
        const postId: string = req.body.postId;
        const question: string = req.body.question;
        const opts: string[] = req.body.options;
        const timestamp: string = req.body.timestamp;
        const expiresAt: string | undefined = req.body.expiresAt;

        // postId must exist
        const postExists = await this.postDb.get(postId).catch(() => null);
        if (!postExists) {
          res.status(404).json({ error: "Associated post not found" });
          return;
        }
        // Compose PollRecord:
        const pollId = `${postId}-poll`;
        const pollOpts: PollOption[] = opts.map((text) => ({
          optionId: uuidv4(),
          text,
          voteCount: 0,
        }));
        const poll: PollRecord = {
          pollId,
          postId,
          question,
          options: pollOpts,
          createdAt: timestamp,
          expiresAt,
        };
        await this.pollDb.put(pollId, poll);
        // Broadcast:
        const event: NewPollEvent = { type: "newPoll", poll };
        const ps =
          (this.context.libp2p as any).pubsub ?? (this.context.libp2p as any).services?.pubsub;
        await ps.publish(
          `/v/polls/${appId}/1.0.0`,
          new TextEncoder().encode(JSON.stringify(event)),
        );
        res.json({ success: true, pollId });
        return;
      } catch (err: any) {
        res.status(500).json({ error: err.message });
        return;
      }
    });

    /** GET /api/v/poll/:pollId → fetch a poll’s details & vote counts */
    router.get("/poll/:pollId", async (req: Request, res: Response) => {
      try {
        const pollId = req.params.pollId;
        const poll = await this.pollDb.get(pollId).catch(() => null);
        if (!poll) {
          res.status(404).json({ error: "Poll not found" });
          return;
        }
        // Count votes from voteDb:
        const updatedOptions: PollOption[] = poll.options.map((opt) => ({ ...opt, voteCount: 0 }));
        for await (const [, v] of this.voteDb.iterator()) {
          if (v.pollId === pollId) {
            const idx = updatedOptions.findIndex((o) => o.optionId === v.optionId);
            if (idx !== -1) {
              updatedOptions[idx].voteCount++;
            }
          }
        }
        res.json({ poll: { ...poll, options: updatedOptions } });
        return;
      } catch (err: any) {
        res.status(500).json({ error: err.message });
        return;
      }
    });

    /** POST /api/v/vote
     *  {
     *    pollId, optionId, timestamp
     *  }
     */
    router.post("/vote", async (req: Request, res: Response) => {
      try {
        const handle = (req as Request & { handle?: string }).handle!;
        const peerId = (req as Request & { peerId?: string }).peerId!;
        const appId = (req as Request & { appId?: string }).appId!;
        const pollId: string = req.body.pollId;
        const optionId: string = req.body.optionId;
        const timestamp: string = req.body.timestamp;

        // Ensure poll exists and not expired:
        const poll = await this.pollDb.get(pollId).catch(() => null);
        if (!poll) {
          res.status(404).json({ error: "Poll not found" });
          return;
        }
        if (poll.expiresAt && Date.now() > Date.parse(poll.expiresAt)) {
          res.status(400).json({ error: "Poll has expired" });
          return;
        }
        // Upsert VoteRecord:
        const key = `${pollId}::${handle}`;
        const vote: VoteRecord = { pollId, optionId, handle, peerId, createdAt: timestamp };
        await this.voteDb.put(key, vote);
        // Broadcast:
        const event: NewVoteEvent = { type: "newVote", vote };
        const ps =
          (this.context.libp2p as any).pubsub ?? (this.context.libp2p as any).services?.pubsub;
        await ps.publish(
          `/v/votes/${appId}/1.0.0`,
          new TextEncoder().encode(JSON.stringify(event)),
        );
        res.json({ success: true });
        return;
      } catch (err: any) {
        res.status(500).json({ error: err.message });
        return;
      }
    });

    // ────────────────────────────────────────────────────────────────────────────
    //   Follow / Unfollow (Friends) Routes
    // ────────────────────────────────────────────────────────────────────────────

    /** POST /api/v/follow/:target */
    router.post("/follow/:targetHandle", async (req: Request, res: Response) => {
      try {
        const actor = (req as Request & { handle?: string }).handle!;
        const target = req.params.targetHandle;
        // Ensure target handle exists:
        try {
          await this.identityDb.get(target);
        } catch {
          res.status(404).json({ error: "Target handle not found" });
          return;
        }
        const current = await this.followDb.get(actor).catch(() => [] as string[]);
        if (!current.includes(target)) {
          current.push(target);
          await this.followDb.put(actor, current);
          // Broadcast:
          const fe: FollowPubEvent = {
            type: "follow",
            from: actor,
            to: target,
            timestamp: new Date().toISOString(),
          };
          const appId = (req as Request & { appId?: string }).appId!;
          const ps =
            (this.context.libp2p as any).pubsub ?? (this.context.libp2p as any).services?.pubsub;
          await ps.publish(
            `/v/follows/${appId}/1.0.0`,
            new TextEncoder().encode(JSON.stringify(fe)),
          );
        }
        res.json({ following: current });
        return;
      } catch (err: any) {
        res.status(500).json({ error: err.message });
        return;
      }
    });

    /** GET /api/v/following */
    router.get("/following", async (req: Request, res: Response) => {
      try {
        const actor = (req as Request & { handle?: string }).handle!;
        const current = await this.followDb.get(actor).catch(() => []);
        res.json({ following: current });
        return;
      } catch (err: any) {
        res.status(500).json({ error: err.message });
        return;
      }
    });

    // ────────────────────────────────────────────────────────────────────────────
    //   Ban Routes
    // ────────────────────────────────────────────────────────────────────────────

    /** POST /api/v/ban/:targetHandle */
    router.post("/ban/:targetHandle", async (req: Request, res: Response) => {
      try {
        const actor = (req as Request & { handle?: string }).handle!;
        const target = req.params.targetHandle;
        // Cannot ban oneself:
        if (actor === target) {
          res.status(400).json({ error: "Cannot ban yourself" });
          return;
        }
        // Record ban:
        const current = await this.banDb.get(actor).catch(() => [] as string[]);
        if (!current.includes(target)) {
          current.push(target);
          await this.banDb.put(actor, current);
          // Broadcast:
          const event: BanPubEvent = {
            type: "ban",
            actor,
            target,
            timestamp: new Date().toISOString(),
          };
          const appId = (req as Request & { appId?: string }).appId!;
          const ps =
            (this.context.libp2p as any).pubsub ?? (this.context.libp2p as any).services?.pubsub;
          await ps.publish(
            `/v/bans/${appId}/1.0.0`,
            new TextEncoder().encode(JSON.stringify(event)),
          );
        }
        res.json({ banned: current });
        return;
      } catch (err: any) {
        res.status(500).json({ error: err.message });
        return;
      }
    });

    /** GET /api/v/bans → list who *I* have banned */
    router.get("/bans", async (req: Request, res: Response) => {
      try {
        const actor = (req as Request & { handle?: string }).handle!;
        const current = await this.banDb.get(actor).catch(() => []);
        res.json({ banned: current });
        return;
      } catch (err: any) {
        res.status(500).json({ error: err.message });
        return;
      }
    });

    // ────────────────────────────────────────────────────────────────────────────
    //   Stream / SSE Endpoints
    // ────────────────────────────────────────────────────────────────────────────

    /** GET /api/v/stream/posts → SSE for new posts from those I follow */
    router.get("/stream/posts", async (req: Request, res: Response) => {
      res.writeHead(200, {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive",
      });
      res.write(":\n\n");

      const me = (req as Request & { handle?: string }).handle!;
      let followArr = await this.followDb.get(me).catch(() => []);
      let followSet = new Set(followArr);
      followSet.add(me);

      // Helper to send a post via SSE
      const sendPost = (p: MicroPost) => {
        res.write(`event: newPost\n`);
        res.write(`data: ${JSON.stringify(p)}\n\n`);
      };

      const appId = (req as Request & { appId?: string }).appId!;
      const ps =
        (this.context.libp2p as any).pubsub ?? (this.context.libp2p as any).services?.pubsub;

      const handler = async (_evtName: string, envelope: any) => {
        const topic: string = envelope.payload.topic;
        const data: Uint8Array = envelope.payload.data;
        try {
          if (topic === `/v/posts/${appId}/1.0.0`) {
            const ev = JSON.parse(new TextDecoder().decode(data)) as NewPostEvent;
            if (followSet.has(ev.post.author)) {
              sendPost(ev.post);
            }
          } else if (topic === `/v/follows/${appId}/1.0.0`) {
            const fe = JSON.parse(new TextDecoder().decode(data)) as FollowPubEvent;
            if (fe.from === me && fe.type === "follow") {
              followSet.add(fe.to);
            }
            if (fe.from === me && fe.type === "unfollow") {
              followSet.delete(fe.to);
            }
          }
        } catch {
          // ignore parse errors
        }
      };

      ps.addEventListener("message", handler);
      req.on("close", () => {
        ps.removeEventListener("message", handler);
      });
    });

    /** GET /api/v/stream/comments → SSE for new comments on posts I follow */
    router.get("/stream/comments", async (req: Request, res: Response) => {
      res.writeHead(200, {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive",
      });
      res.write(":\n\n");

      const me = (req as Request & { handle?: string }).handle!;
      let followArr = await this.followDb.get(me).catch(() => []);
      let followSet = new Set(followArr);
      followSet.add(me);

      const sendComment = (c: CommentRecord) => {
        res.write(`event: newComment\n`);
        res.write(`data: ${JSON.stringify(c)}\n\n`);
      };

      const appId = (req as Request & { appId?: string }).appId!;
      const ps =
        (this.context.libp2p as any).pubsub ?? (this.context.libp2p as any).services?.pubsub;

      const handler = async (_evtName: string, envelope: any) => {
        const topic: string = envelope.payload.topic;
        const data: Uint8Array = envelope.payload.data;
        try {
          if (topic === `/v/comments/${appId}/1.0.0`) {
            const ev = JSON.parse(new TextDecoder().decode(data)) as NewCommentEvent;
            // Only send comments on posts whose author we follow:
            const parentPost = await this.postDb.get(ev.comment.postId).catch(() => null);
            if (parentPost && followSet.has(parentPost.author)) {
              sendComment(ev.comment);
            }
          } else if (topic === `/v/follows/${appId}/1.0.0`) {
            const fe = JSON.parse(new TextDecoder().decode(data)) as FollowPubEvent;
            if (fe.from === me && fe.type === "follow") {
              followSet.add(fe.to);
            }
            if (fe.from === me && fe.type === "unfollow") {
              followSet.delete(fe.to);
            }
          }
        } catch {
          // ignore parse errors
        }
      };

      ps.addEventListener("message", handler);
      req.on("close", () => {
        ps.removeEventListener("message", handler);
      });
    });

    // ────────────────────────────────────────────────────────────────────────────
    //   Poll Stream → SSE for new poll creations & votes
    // ────────────────────────────────────────────────────────────────────────────

    /** GET /api/v/stream/polls → SSE for new polls I can see (my follows) */
    router.get("/stream/polls", async (req: Request, res: Response) => {
      res.writeHead(200, {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive",
      });
      res.write(":\n\n");

      const me = (req as Request & { handle?: string }).handle!;
      let followArr = await this.followDb.get(me).catch(() => []);
      let followSet = new Set(followArr);
      followSet.add(me);

      const sendPoll = (p: PollRecord) => {
        res.write(`event: newPoll\n`);
        res.write(`data: ${JSON.stringify(p)}\n\n`);
      };

      const appId = (req as Request & { appId?: string }).appId!;
      const ps =
        (this.context.libp2p as any).pubsub ?? (this.context.libp2p as any).services?.pubsub;

      const handler = async (_evtName: string, envelope: any) => {
        const topic: string = envelope.payload.topic;
        const data: Uint8Array = envelope.payload.data;
        try {
          if (topic === `/v/polls/${appId}/1.0.0`) {
            const ev = JSON.parse(new TextDecoder().decode(data)) as NewPollEvent;
            // Only show polls whose parent post author we follow:
            const parentPost = await this.postDb.get(ev.poll.postId).catch(() => null);
            if (parentPost && followSet.has(parentPost.author)) {
              sendPoll(ev.poll);
            }
          } else if (topic === `/v/follows/${appId}/1.0.0`) {
            const fe = JSON.parse(new TextDecoder().decode(data)) as FollowPubEvent;
            if (fe.from === me && fe.type === "follow") {
              followSet.add(fe.to);
            }
            if (fe.from === me && fe.type === "unfollow") {
              followSet.delete(fe.to);
            }
          }
        } catch {
          // ignore parse errors
        }
      };

      ps.addEventListener("message", handler);
      req.on("close", () => {
        ps.removeEventListener("message", handler);
      });
    });

    // ────────────────────────────────────────────────────────────────────────────
    //   Ban / Unban Stream → SSE for ban events affecting me
    // ────────────────────────────────────────────────────────────────────────────

    /** GET /api/v/stream/bans → SSE for new bans where I am the target */
    router.get("/stream/bans", async (req: Request, res: Response) => {
      res.writeHead(200, {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive",
      });
      res.write(":\n\n");

      const me = (req as Request & { handle?: string }).handle!;

      const sendBan = (b: BanPubEvent) => {
        if (b.target === me) {
          res.write(`event: ban\n`);
          res.write(`data: ${JSON.stringify(b)}\n\n`);
        }
      };

      const appId = (req as Request & { appId?: string }).appId!;
      const ps =
        (this.context.libp2p as any).pubsub ?? (this.context.libp2p as any).services?.pubsub;

      const handler = async (_evtName: string, envelope: any) => {
        const topic: string = envelope.payload.topic;
        const data: Uint8Array = envelope.payload.data;
        try {
          if (topic === `/v/bans/${appId}/1.0.0`) {
            const ev = JSON.parse(new TextDecoder().decode(data)) as BanPubEvent;
            sendBan(ev);
          }
        } catch {
          // ignore parse errors
        }
      };

      ps.addEventListener("message", handler);
      req.on("close", () => {
        ps.removeEventListener("message", handler);
      });
    });

    return router;
  }
}

filename: packages/vinyl-peer-plugin-v/src/types.ts
filecontent:
/**
 * ─────────────────────────────────────────────────────────────────────────────
 *   Type Definitions for VPlugin (per application "appId")
 * ─────────────────────────────────────────────────────────────────────────────
 */

/** A single micro‐post (up to 280 characters). */
export interface MicroPost {
  postId: string; // "<handle>-<timestamp>-<uuid>"
  author: string; // handle
  peerId: string; // libp2p PeerId
  text: string; // up to 280 chars (or poll reference)
  createdAt: string; // ISO timestamp
  isPoll?: boolean; // true if this post represents a poll
}

/** A comment on a post. */
export interface CommentRecord {
  commentId: string; // "<postId>-comment-<uuid>"
  postId: string; // where this comment lives
  author: string; // handle
  peerId: string; // libp2p PeerId
  text: string; // comment text (≤280 chars)
  createdAt: string; // ISO timestamp
}

/** Like/Dislike record for a single post by a single user. */
export interface LikeRecord {
  postId: string;
  handle: string;
  peerId: string;
  isLike: boolean; // true = like, false = dislike
  createdAt: string; // ISO timestamp
}

/** A poll attached to a post. */
export interface PollOption {
  optionId: string; // UUID
  text: string; // Option text
  voteCount: number;
}

export interface PollRecord {
  pollId: string; // "<postId>-poll"
  postId: string; // which post triggered this poll
  question: string;
  options: PollOption[]; // initial options
  createdAt: string; // ISO timestamp
  expiresAt?: string; // optional expiry
}

/** A vote cast by a user on a poll. */
export interface VoteRecord {
  pollId: string;
  optionId: string;
  handle: string;
  peerId: string;
  createdAt: string; // ISO timestamp
}

/** Follow/unfollow events (re-used from older). */
export interface FollowEvent {
  type: "follow" | "unfollow";
  from: string; // actor handle
  to: string; // target handle
  timestamp: string;
}

/** A ban record—when one handle bans another. */
export interface BanRecord {
  actor: string; // handle who issued the ban
  target: string; // handle being banned
  timestamp: string; // ISO
}

/** Identity record linking a stable handle to libp2p PeerIds. */
export interface IdentityRecord {
  handle: string; // e.g. "alice"
  currentPeerId: string; // active PeerId
  previousPeerIds: string[]; // prior PeerIds
  createdAt: string;
  sig: string; // signature by previous key (or self if new)
}

/** PubSub events */
export interface NewPostEvent {
  type: "newPost";
  post: MicroPost;
}
export interface NewCommentEvent {
  type: "newComment";
  comment: CommentRecord;
}
export interface NewLikeEvent {
  type: "newLike";
  like: LikeRecord;
}
export interface NewPollEvent {
  type: "newPoll";
  poll: PollRecord;
}
export interface NewVoteEvent {
  type: "newVote";
  vote: VoteRecord;
}
export interface FollowPubEvent extends FollowEvent {}
export interface BanPubEvent {
  type: "ban";
  actor: string;
  target: string;
  timestamp: string;
}

filename: packages/vinyl-peer-plugin-v/src/index.ts
filecontent:
export { VPlugin } from "./VPlugin.js";

filename: packages/vinyl-peer-plugin-advanced-sharding/tsconfig.esm.json
filecontent:
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "module": "ESNext",                // produce ESM
    "target": "ES2020",                // or whatever target you prefer
    "outDir": "dist/esm",              // everything goes under dist/esm
    "declaration": true,               // emit .d.ts files
    "declarationDir": "dist/esm",      // put .d.ts next to .js
    "strict": true,
    "esModuleInterop": true,
    "moduleResolution": "node",
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}

filename: packages/vinyl-peer-plugin-advanced-sharding/package.json
filecontent:
{
  "name": "vinyl-peer-plugin-advanced-sharding",
  "version": "0.0.1",
  "authors": [
    "KDLabs"
  ],
  "type": "module",
  "main": "dist/cjs/index.js",
  "module": "dist/esm/index.js",
  "types": "dist/esm/index.d.ts",
  "exports": {
    "import": "./dist/esm/index.js",
    "require": "./dist/cjs/index.js"
  },
  "scripts": {
    "build:esm": "tsc -p tsconfig.esm.json",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build": "rimraf dist && npm run build:esm && npm run build:cjs",
    "test": "vitest"
  },
  "dependencies": {
    "@helia/unixfs": "^5.0.3",
    "@types/multer": "^1.4.7",
    "express": "^5.1.0",
    "helia": "^5.4.2",
    "level": "^10.0.0",
    "libp2p": "^2.8.8",
    "multer": "^1.4.5-lts.1",
    "multiformats": "^13.3.6",
    "rabin-wasm": "^0.1.5",
    "vinyl-peer-protocol": "workspace:*"
  },
  "devDependencies": {
    "@types/express": "^5.0.2",
    "@types/node": "^18.7.23",
    "typescript": "^5.7.3",
    "vitest": "^3.0.5"
  }
}

filename: packages/vinyl-peer-plugin-advanced-sharding/tsconfig.cjs.json
filecontent:
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "module": "CommonJS",     // produce CJS
    "target": "ES2020",       
    "outDir": "dist/cjs",     // everything goes under dist/cjs
    "declaration": false      // we don’t need .d.ts here (we already emitted them under dist/esm)
  },
  "include": ["src/**/*"]
}

filename: packages/vinyl-peer-plugin-advanced-sharding/src/AdvancedShardingPlugin.ts
filecontent:
// File: AdvancedShardingPlugin.ts

import { Router, Request, Response } from "express";
import multer from "multer";
import {
  BasePlugin,
  PluginCapabilities,
  PluginContext,
  VinylPeerPlugin,
} from "vinyl-peer-protocol";
import { Level } from "level";
import path from "path";
import type { AdvancedManifest, ShardIndexEntry } from "./types.js";
import { encodeFileToAdvancedShards } from "./utils/encoder.js";
import { decodeAdvancedShardsToFile } from "./utils/decoder.js";
import { startAutoRepair } from "./utils/autoRepair.js";
import configRoute from "./routes/config.js";
import statusRoute from "./routes/status.js";

// Create a multer instance for handling `multipart/form-data` uploads
const upload = multer({ storage: multer.memoryStorage() });

export class AdvancedShardingPlugin extends BasePlugin implements VinylPeerPlugin {
  protected context!: PluginContext;
  private advDb!: Level<string, AdvancedManifest>;

  // Use ReturnType<typeof setInterval> so TypeScript understands it matches NodeJS.Timeout
  private autoRepairTimer!: ReturnType<typeof setInterval>;

  getCapabilities(): PluginCapabilities {
    return {
      name: "vinyl-peer-plugin-advanced-sharding",
      version: "0.1.0",
      protocols: [],
      capabilities: ["storage"],
      permissions: {
        accessFiles: true,
        useNetwork: true,
        modifyPeers: false,
        exposeHttp: true,
      },
    };
  }

  async initialize(context: PluginContext): Promise<boolean> {
    const ok = await super.initialize(context);
    if (!ok) return false;
    this.context = context;

    // 1) Create a LevelDB under ./adv-shard-manifests
    const folder = path.join(process.cwd(), "adv-shard-manifests");
    this.advDb = new Level<string, AdvancedManifest>(folder, { valueEncoding: "json" });

    return true;
  }

  async start(): Promise<void> {
    await super.start();

    // 2) Begin auto‐repair loop every 300s by default
    const defaultInterval = 300; // seconds

    this.autoRepairTimer = global.setInterval(() => {
      startAutoRepair(
        this.context.helia,
        this.advDb,
        async (entry: ShardIndexEntry) => {
          // Append to matching manifest’s index
          for await (const [id, manifest] of this.advDb.iterator()) {
            if (manifest.chunks.some((c) => c.shards.find((s) => s.cid === entry.shardCid))) {
              manifest.shardIndex.push(entry);
              try {
                await this.advDb.put(id, manifest);
              } catch (err) {
                console.error("[AdvancedSharding] failed to update shardIndex in DB:", err);
              }
              break;
            }
          }
        },
        // Provide per-manifest override settings; must return all required fields
        async (_manifestId: string) => {
          return {
            dataShards: 0,
            parityShards: 0,
            minReplicas: 0,
            autoRepairIntervalSeconds: defaultInterval,
          };
        },
        defaultInterval,
      );
    }, defaultInterval * 1000);
  }

  async stop(): Promise<void> {
    clearInterval(this.autoRepairTimer);
    await this.advDb.close();
    await super.stop();
  }

  setupProtocols(): void {
    // No libp2p protocols needed
  }

  async handleProtocol(_p: string, _s: any, _peerId: string): Promise<void> {
    // No custom protocol handling
  }

  getHttpNamespace(): string {
    return "/api/adv-shard";
  }

  getHttpRouter(): Router {
    const router = Router();

    // POST /api/adv-shard/upload
    router.post("/upload", upload.single("file"), async (req: Request, res: Response) => {
      const file = (req as any).file as Express.Multer.File;
      if (!file || !file.buffer) {
        res.status(400).json({ error: "Missing file" });
        return;
      }
      const dataShards = parseInt(req.body.dataShards) || 6;
      const parityShards = parseInt(req.body.parityShards) || 3;
      const shardSize = parseInt(req.body.shardSize) || 64 * 1024;

      try {
        const { manifest } = await encodeFileToAdvancedShards(file.buffer, {
          dataShards,
          parityShards,
          filename: file.originalname,
          mimeType: file.mimetype || "application/octet-stream",
          helia: this.context.helia,
          ownerPeer: (this.context.helia as any).libp2p.peerId.toString(),
          putShardIndex: async (entry) => {
            // Immediately update each matching manifest’s index
            await manifestShardIndex(this.advDb, entry);
          },
          config: { shardSize },
        });

        const manifestId = `${this.context.nodeId}-${Date.now()}`;
        await this.advDb.put(manifestId, manifest);
        res.json({ id: manifestId, chunks: manifest.chunks });
      } catch (err) {
        console.error("[adv-shard] upload error:", err);
        res.status(500).json({ error: "Upload/encoding failed" });
      }
    });

    // GET /api/adv-shard/recover/:id
    router.get("/recover/:id", async (req: Request, res: Response) => {
      const id = req.params.id;
      let manifest: AdvancedManifest;
      try {
        manifest = await this.advDb.get(id);
      } catch {
        res.status(404).json({ error: `Manifest ${id} not found` });
        return;
      }

      try {
        const fileBuf = await decodeAdvancedShardsToFile(manifest, this.context.helia);
        res.setHeader("Content-Type", manifest.mimeType);
        res.setHeader("Content-Disposition", `attachment; filename="${manifest.filename}"`);
        res.send(fileBuf);
      } catch (err) {
        console.error("[adv-shard] recover error:", err);
        res.status(500).json({ error: "Recovery failed" });
      }
    });

    // Mount config & status routes
    router.use(configRoute(this.context));
    router.get("/status/:id", statusRoute(this.context, this.advDb));

    return router;
  }
}

/**
 * Helper: when a new ShardIndexEntry arrives, append it to the matching manifest’s index.
 */
async function manifestShardIndex(advDb: Level<string, AdvancedManifest>, entry: ShardIndexEntry) {
  for await (const [id, manifest] of advDb.iterator()) {
    if (manifest.chunks.some((c) => c.shards.find((s) => s.cid === entry.shardCid))) {
      manifest.shardIndex.push(entry);
      try {
        await advDb.put(id, manifest);
      } catch (err) {
        console.error("[AdvancedSharding] manifestShardIndex put failed:", err);
      }
      break;
    }
  }
}

filename: packages/vinyl-peer-plugin-advanced-sharding/src/declaration.d.ts
filecontent:
declare module "rabin-wasm";

filename: packages/vinyl-peer-plugin-advanced-sharding/src/utils/autoRepair.ts
filecontent:
import type { Helia } from "helia";
import { CID } from "multiformats/cid";
import type { AdvancedManifest, ShardIndexEntry } from "../types.js";
import { decodeAdvancedShardsToFile } from "./decoder.js";
import type { Level } from "level";

/**
 * Every `intervalSeconds`, scan the entire advDb (streaming), check DHT entries,
 * re-encode or re-pin if under‐replicated, and update DHT index entries.
 *
 * Production tweaks:
 *  - Use streaming iteration to avoid loading all keys at once.
 *  - Surround each manifest‐repair in try/catch so one failure doesn’t kill the loop.
 *  - Honor `minReplicas` from an in‐memory (or persisted) config, if provided by user.
 */
export function startAutoRepair(
  helia: Helia,
  advDb: Level<string, AdvancedManifest>,
  putShardIndex: (entry: ShardIndexEntry) => Promise<void>,
  getConfig: (manifestId: string) => Promise<{
    dataShards: number;
    parityShards: number;
    minReplicas: number;
    autoRepairIntervalSeconds: number;
  }>,
  intervalSeconds: number,
): NodeJS.Timer {
  return setInterval(async () => {
    try {
      for await (const [manifestId, manifest] of advDb.iterator()) {
        // Default config values
        let config = {
          dataShards: manifest.dataShards,
          parityShards: manifest.parityShards,
          minReplicas: 3,
          autoRepairIntervalSeconds: intervalSeconds,
        };
        try {
          const override = await getConfig(manifestId);
          config = { ...config, ...override };
        } catch {
          // Use defaults if no override
        }

        for (const chunk of manifest.chunks) {
          for (const shardInfo of chunk.shards) {
            try {
              const cidObj = CID.parse(shardInfo.cid);
              const found = await (helia.blockstore as any).get(cidObj);
              if (!found) {
                // Missing → reconstruct entire file (could optimize to per‐chunk)
                const fullFile = await decodeAdvancedShardsToFile(manifest, helia);
                // Re-encode with the same parameters (must include ownerPeer)
                const { encodeFileToAdvancedShards } = await import("./encoder.js");
                const ownerPeer = (helia as any).libp2p.peerId.toString();
                const { manifest: newManifest } = await encodeFileToAdvancedShards(fullFile, {
                  dataShards: config.dataShards,
                  parityShards: config.parityShards,
                  filename: manifest.filename,
                  mimeType: manifest.mimeType,
                  helia,
                  ownerPeer,
                  putShardIndex,
                  config: { shardSize: manifest.shardSize },
                });
                await advDb.put(manifestId, newManifest);
                break; // move to next manifest after repair
              } else {
                // Update “lastSeen” in DHT index
                await putShardIndex({
                  shardCid: shardInfo.cid,
                  ownerPeer: (helia as any).libp2p.peerId.toString(),
                  lastSeen: new Date().toISOString(),
                  isParity: shardInfo.isParity,
                });
              }
            } catch {
              // continue to next shard if any error
            }
          }
        }
      }
    } catch (err) {
      console.error("[AdvancedSharding][autoRepair] uncaught error:", err);
    }
  }, intervalSeconds * 1000);
}

filename: packages/vinyl-peer-plugin-advanced-sharding/src/utils/encoder.ts
filecontent:
// File: utils/encoder.ts

import { sha256 } from "multiformats/hashes/sha2";
import * as rawCodec from "multiformats/codecs/raw";
import { CID } from "multiformats/cid";
import type { Helia } from "helia";
import type { AdvancedManifest, RSShardInfo, ChunkInfo, ShardIndexEntry } from "../types.js";
import { createRequire } from "module";
import { rabinCut } from "rabin-wasm";

const cjsRequire = createRequire(import.meta.url);
const ReedSolomon = cjsRequire("@ronomon/reed-solomon");

/**
 * Encode a Buffer into Rabin‐fingerprinted chunks, then Reed‐Solomon shards per chunk.
 * - Stores each shard in Helia's blockstore.
 * - Indexes each shard in DHT via `putShardIndex`.
 *
 * Production tweaks:
 *  - Streams Rabin chunking to avoid huge‐buffer peaks
 *  - Batch‐uploads of shards (back‐pressure)
 *  - Configurable shardSize from opts.config.shardSize
 */
export async function encodeFileToAdvancedShards(
  buffer: Buffer,
  opts: {
    dataShards: number;
    parityShards: number;
    filename: string;
    mimeType: string;
    helia: Helia;
    ownerPeer: string;
    putShardIndex: (entry: ShardIndexEntry) => Promise<void>;
    config: {
      shardSize: number; // e.g. 64 * 1024
    };
  },
): Promise<{ manifest: AdvancedManifest }> {
  const { dataShards, parityShards, filename, mimeType, helia, ownerPeer, putShardIndex } = opts;
  const totalShards = dataShards + parityShards;
  const originalFileSize = buffer.length;
  const shardSize = opts.config.shardSize;

  // 1) Rabin fingerprint chunking → array of { start, length }
  const chunkBounds: { start: number; length: number }[] = rabinCut(buffer, {
    min: shardSize / 2,
    avg: shardSize,
    max: shardSize * 2,
  });
  const chunks: ChunkInfo[] = [];

  // 2) For each chunk, RS-encode and store shards
  for (const { start, length } of chunkBounds) {
    const chunkBuf = buffer.subarray(start, start + length);

    // Zero‐pad chunkBuf to dataShards * shardSize
    const dataBuf = Buffer.alloc(dataShards * shardSize, 0);
    chunkBuf.copy(dataBuf, 0, 0, chunkBuf.length);
    const parityBuf = Buffer.alloc(parityShards * shardSize, 0);

    // Create RS context and encode
    const rsContext = ReedSolomon.create(dataShards, parityShards);
    await new Promise<void>((resolve, reject) => {
      let srcMask = 0;
      for (let i = 0; i < dataShards; i++) srcMask |= 1 << i;
      let tgtMask = 0;
      for (let j = 0; j < parityShards; j++) tgtMask |= 1 << (dataShards + j);

      ReedSolomon.encode(
        rsContext,
        srcMask,
        tgtMask,
        dataBuf,
        0,
        dataBuf.byteLength,
        parityBuf,
        0,
        parityBuf.byteLength,
        (err: Error | null) => {
          if (err) reject(err);
          else resolve();
        },
      );
    });

    // 3) Split and store each data & parity shard
    const shardInfos: RSShardInfo[] = [];
    for (let i = 0; i < totalShards; i++) {
      const slice =
        i < dataShards
          ? dataBuf.subarray(i * shardSize, (i + 1) * shardSize)
          : parityBuf.subarray((i - dataShards) * shardSize, (i - dataShards + 1) * shardSize);

      // Hash & create CID v1+raw
      const hash = await sha256.digest(Uint8Array.from(slice));
      const cid = CID.createV1(rawCodec.code, hash);

      // Store in Helia blockstore (backpressure aware)
      await (helia.blockstore as any).put(cid, Uint8Array.from(slice));

      // Index this shard in DHT
      const entry: ShardIndexEntry = {
        shardCid: cid.toString(),
        ownerPeer,
        lastSeen: new Date().toISOString(),
        isParity: i >= dataShards,
      };
      try {
        await putShardIndex(entry);
      } catch (err) {
        console.error("[AdvancedSharding][encoder] putShardIndex failed:", err);
      }

      shardInfos.push({
        index: i,
        cid: cid.toString(),
        isParity: i >= dataShards,
      });
    }

    chunks.push({
      start,
      length,
      shards: shardInfos,
    });
  }

  // 4) Build final manifest
  const manifest: AdvancedManifest = {
    filename,
    mimeType,
    originalFileSize,
    dataShards,
    parityShards,
    totalShards,
    shardSize,
    createdAt: new Date().toISOString(),
    chunks,
    shardIndex: [], // filled later in status/autoRepair
  };

  return { manifest };
}

filename: packages/vinyl-peer-plugin-advanced-sharding/src/utils/decoder.ts
filecontent:
import type { Helia } from "helia";
import { CID } from "multiformats/cid";
import type { AdvancedManifest } from "../types.js";
import { createRequire } from "module";

const cjsRequire = createRequire(import.meta.url);
const ReedSolomon = cjsRequire("@ronomon/reed-solomon");

/**
 * Decode an AdvancedManifest:
 * - For each chunk, attempt to fetch data‐shards from Helia. If any are missing:
 *     • fetch parity‐shards → run ReedSolomon.decode to reconstruct.
 * - Concatenate each chunk’s data in order → full Buffer.
 */
export async function decodeAdvancedShardsToFile(
  manifest: AdvancedManifest,
  helia: Helia,
): Promise<Buffer> {
  const { dataShards, parityShards, shardSize, originalFileSize, chunks } = manifest;
  const totalShards = dataShards + parityShards;
  const outputBuffers: Buffer[] = [];

  for (const chunk of chunks) {
    // 1) Build an array of length `totalShards`.
    //    Each index will hold either a Buffer (if that shard was fetched)
    //    or `undefined` if missing.
    const rawShards: Array<Buffer | undefined> = new Array(totalShards).fill(undefined);

    // 2) Try to load every shard that the manifest knows about.
    for (const shardInfo of chunk.shards) {
      try {
        const cidObj = CID.parse(shardInfo.cid);
        // helia.blockstore.get(...) returns a Uint8Array | null
        const u8: Uint8Array | null = await (helia.blockstore as any).get(cidObj);
        if (u8 != null) {
          rawShards[shardInfo.index] = Buffer.from(u8);
        }
      } catch {
        rawShards[shardInfo.index] = undefined;
      }
    }

    // 3) Count how many shards are missing
    const missingIndices = rawShards
      .map((b, i) => (b === undefined ? i : null))
      .filter((i) => i !== null);

    if (missingIndices.length === 0) {
      // All data‐shards are present. We can grab the first `dataShards` slices.
      const dataBuffers = rawShards.slice(0, dataShards) as Buffer[];
      // Concatenate and then truncate to the exact chunk.length to drop padding.
      const chunkBuf = Buffer.concat(dataBuffers).slice(0, chunk.length);
      outputBuffers.push(chunkBuf);
      continue;
    }

    // 4) Some data‐shards are missing. Attempt Reed-Solomon reconstruction.
    const recoveredAll: Buffer = await new Promise((resolve, reject) => {
      ReedSolomon.decode(
        rawShards,
        { dataShards, parityShards },
        (err: Error | null, recovered: Buffer | undefined) => {
          if (err) return reject(err);
          if (!recovered) return reject(new Error("RS decode did not return a buffer"));
          resolve(recovered);
        },
      );
    });

    // 5) The returned `recoveredAll` contains (dataShards + parityShards) * shardSize bytes.
    //    We only want the first dataShards * shardSize bytes, then we crop to chunk.length.
    const dataPortion = recoveredAll.slice(0, dataShards * shardSize);
    const chunkBuf = dataPortion.slice(0, chunk.length);
    outputBuffers.push(chunkBuf);
  }

  // 6) Stitch all the chunk buffers together, then trim to the originalFileSize.
  return Buffer.concat(outputBuffers).slice(0, originalFileSize);
}

filename: packages/vinyl-peer-plugin-advanced-sharding/src/types.ts
filecontent:
/**
 * RSShardInfo: describes a single RS/erasure‐coded shard.
 */
export interface RSShardInfo {
  index: number; // 0 ≤ index < totalShards
  cid: string; // IPFS/Helia CID
  isParity: boolean; // true if parity shard
}

/**
 * ChunkInfo: describes a Rabin‐chunked block.
 */
export interface ChunkInfo {
  start: number; // byte offset in original file
  length: number; // length in bytes
  shards: RSShardInfo[]; // all RS shards covering this chunk
}

/**
 * ShardIndexEntry: for DHT indexing – maps shard‐CID → ownerPeer + timestamp.
 */
export interface ShardIndexEntry {
  shardCid: string;
  ownerPeer: string;
  lastSeen: string; // ISO timestamp
  isParity: boolean;
}

/**
 * Tunables (per‐file override):
 */
export interface ShardingConfig {
  dataShards: number;
  parityShards: number;
  minReplicas: number;
  autoRepairIntervalSeconds: number;
}

/**
 * Advanced manifest describing both chunk‐level layout + RS shards.
 */
export interface AdvancedManifest {
  filename: string;
  mimeType: string;
  originalFileSize: number;
  dataShards: number;
  parityShards: number;
  totalShards: number;
  shardSize: number;
  createdAt: string;
  chunks: ChunkInfo[]; // for partial fetch
  shardIndex: ShardIndexEntry[]; // DHT rep map
}

filename: packages/vinyl-peer-plugin-advanced-sharding/src/index.ts
filecontent:
export * from "./AdvancedShardingPlugin.js";

filename: packages/vinyl-peer-plugin-advanced-sharding/src/routes/status.ts
filecontent:
import { Router, Request, Response } from "express";
import type { PluginContext } from "vinyl-peer-protocol";
import type { AdvancedManifest, ShardIndexEntry } from "../types.js";
import type { Level } from "level";

interface StatusPayload {
  manifest: AdvancedManifest;
  shardIndex: ShardIndexEntry[];
}

/**
 * GET /api/adv-shard/status/:id
 *   Return the manifest + current replication counts (via DHT‐stored shardIndex).
 */
export default function statusRoute(
  context: PluginContext,
  advDb: Level<string, AdvancedManifest>,
): Router {
  const router = Router();

  router.get(
    "/status/:id",
    async (req: Request, res: Response<StatusPayload | { error: string }>) => {
      const id = req.params.id;
      let manifest: AdvancedManifest;
      try {
        manifest = await advDb.get(id);
      } catch {
        res.status(404).json({ error: `Manifest ${id} not found` });
        return;
      }

      // Return manifest & its DHT‐aggregated shardIndex
      res.json({
        manifest,
        shardIndex: manifest.shardIndex as ShardIndexEntry[],
      });
    },
  );

  return router;
}

filename: packages/vinyl-peer-plugin-advanced-sharding/src/routes/config.ts
filecontent:
import { Router, Request, Response } from "express";
import type { PluginContext } from "vinyl-peer-protocol";
import type { ShardingConfig } from "../types.js";

/**
 * GET /api/adv-shard/config/:id
 *   Return current per‐manifest sharding config (in-memory override).
 * POST /api/adv-shard/config/:id
 *   Accept JSON { dataShards?, parityShards?, minReplicas?, autoRepairIntervalSeconds? }
 *   and update the in‐memory config.  (User responsible for re‐encode if K/M changed.)
 */
export default function configRoute(context: PluginContext): Router {
  // In‐memory override store: manifestId → ShardingConfig
  const inMemoryConfig: Record<string, Partial<ShardingConfig>> = {};

  const router: Router = Router();

  router.get(
    "/config/:id",
    (req: Request, res: Response<Partial<ShardingConfig> | { error: string }>) => {
      const id = req.params.id;
      res.json(inMemoryConfig[id] || {});
    },
  );

  router.post(
    "/config/:id",
    (
      req: Request,
      res: Response<{ success: true; config: Partial<ShardingConfig> } | { error: string }>,
    ) => {
      const id = req.params.id;
      const updates = req.body as Partial<ShardingConfig>;
      if (typeof updates !== "object" || Array.isArray(updates)) {
        res.status(400).json({ error: "Invalid config format" });
        return;
      }
      inMemoryConfig[id] = { ...(inMemoryConfig[id] || {}), ...updates };
      res.json({ success: true, config: inMemoryConfig[id] });
    },
  );

  return router;
}

filename: packages/vinyl-peer-plugin-rs/tsconfig.esm.json
filecontent:
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "module": "ESNext",                // produce ESM
    "target": "ES2020",                // or whatever target you prefer
    "outDir": "dist/esm",              // everything goes under dist/esm
    "declaration": true,               // emit .d.ts files
    "declarationDir": "dist/esm",      // put .d.ts next to .js
    "strict": true,
    "esModuleInterop": true,
    "moduleResolution": "node",
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}

filename: packages/vinyl-peer-plugin-rs/package.json
filecontent:
{
  "name": "vinyl-peer-plugin-rs",
  "version": "0.0.1",
  "authors": [
    "KDLabs"
  ],
  "type": "module",
  "module": "dist/esm/index.js",
  "types": "dist/esm/index.d.ts",
  "exports": {
    "import": "./dist/esm/index.js"
  },
  "scripts": {
    "build:esm": "tsc -p tsconfig.esm.json",
    "build": "rimraf dist && npm run build:esm",
    "test": "vitest"
  },
  "dependencies": {
    "@helia/unixfs": "^5.0.3",
    "@ronomon/reed-solomon": "^6.0.0",
    "@types/multer": "^1.4.7",
    "express": "^5.1.0",
    "helia": "^5.4.2",
    "level": "^10.0.0",
    "multer": "^1.4.5-lts.1",
    "multiformats": "^13.3.6",
    "uuid": "^11.1.0",
    "vinyl-peer-protocol": "workspace:*"
  },
  "devDependencies": {
    "@types/express": "^5.0.2",
    "@types/node": "^18.7.23",
    "rimraf": "^5.0.0",
    "typescript": "^5.7.3",
    "vitest": "^3.0.5"
  }
}

filename: packages/vinyl-peer-plugin-rs/tsconfig.cjs.json
filecontent:
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "module": "CommonJS",     // produce CJS
    "target": "ES2020",       
    "outDir": "dist/cjs",     // everything goes under dist/cjs
    "declaration": false      // we don’t need .d.ts here (we already emitted them under dist/esm)
  },
  "include": ["src/**/*"]
}

filename: packages/vinyl-peer-plugin-rs/src/ReedSolomonPlugin.ts
filecontent:
import express, { Router } from "express";
import multer from "multer";
import {
  BasePlugin,
  PluginCapabilities,
  PluginContext,
  VinylPeerPlugin,
} from "vinyl-peer-protocol";
import { Level } from "level";
import path from "path";

import uploadRoute from "./routes/upload.js";
import recoverRoute from "./routes/recover.js";
import type { RSManifest } from "./types.js";

export class ReedSolomonPlugin extends BasePlugin implements VinylPeerPlugin {
  protected context!: PluginContext;
  private rsDb!: Level<string, RSManifest>;
  private upload: multer.Multer;

  constructor() {
    super();
    // Use in-memory storage for shards upload
    this.upload = multer({ storage: multer.memoryStorage() });
  }

  getCapabilities(): PluginCapabilities {
    return {
      name: "vinyl-peer-plugin-rs",
      version: "0.0.1",
      protocols: [], // no custom libp2p protocols
      capabilities: ["storage"],
      permissions: {
        accessFiles: true, // may read core fileDb if needed
        useNetwork: true, // needs Helia/IPFS access
        modifyPeers: false,
        exposeHttp: true, // will expose HTTP under /api/rs
      },
    };
  }

  async initialize(context: PluginContext): Promise<boolean> {
    const ok = await super.initialize(context);
    if (!ok) return false;

    this.context = context;
    // Create a LevelDB directory under ./rs-manifests (relative to CWD)
    const rsFolder = path.join(process.cwd(), "rs-manifests");
    this.rsDb = new Level<string, RSManifest>(rsFolder, { valueEncoding: "json" });
    return true;
  }

  async start(): Promise<void> {
    await super.start();
    // No additional libp2p logic on start
  }

  async stop(): Promise<void> {
    await this.rsDb.close();
    await super.stop();
  }

  setupProtocols(): void {
    // No custom libp2p protocols
  }

  async handleProtocol(_protocol: string, _stream: any, _peerId: string): Promise<void> {
    // Not used
  }

  getHttpNamespace(): string {
    return "/api/rs";
  }

  /**
   * Mount two routes:
   *   - POST /api/rs/upload  → multer, then uploadRoute
   *   - GET  /api/rs/recover/:id → recoverRoute
   */
  getHttpRouter(): Router {
    const router = Router();

    // 1) Upload
    router.post(
      "/upload",
      this.upload.single("file"), // multer middleware to populate req.file
      uploadRoute(this.context, this.rsDb),
    );

    // 2) Recover
    router.get("/recover/:id", recoverRoute(this.context, this.rsDb));

    return router;
  }

  /**
   * Programmatic “store” method for other plugins (if needed):
   * - Accepts a Buffer, encodes into shards, writes manifest to rsDb
   */
  async store(
    buffer: Buffer,
    opts: { filename: string; mimeType: string; dataShards?: number; parityShards?: number },
  ): Promise<{ manifestId: string }> {
    const dataShards = opts.dataShards ?? 6;
    const parityShards = opts.parityShards ?? 3;

    // Dynamically import encoder helper
    const { encodeFileToShards } = await import("./utils/encoder.js");
    const { manifest } = await encodeFileToShards(buffer, {
      dataShards,
      parityShards,
      filename: opts.filename,
      mimeType: opts.mimeType,
      helia: this.context.helia,
    });

    const manifestId = `${this.context.nodeId}-${Date.now()}`;
    await this.rsDb.put(manifestId, manifest);
    return { manifestId };
  }

  /**
   * Programmatic “retrieve” method for other plugins:
   * - Reads manifest, decodes all shards (via decoder helper), returns Buffer
   */
  async retrieve(manifestId: string): Promise<Buffer> {
    const { decodeShardsToFile } = await import("./utils/decoder.js");
    const manifest = await this.rsDb.get(manifestId);
    return decodeShardsToFile(manifest, this.context.helia);
  }
}

filename: packages/vinyl-peer-plugin-rs/src/utils/encoder.ts
filecontent:
import { sha256 } from "multiformats/hashes/sha2";
import * as rawCodec from "multiformats/codecs/raw";
import { CID } from "multiformats/cid";
import type { Helia } from "helia";
import type { RSManifest, RSShardInfo } from "../types.js";
import { createRequire } from "module";

const cjsRequire = createRequire(import.meta.url);
const ReedSolomon = cjsRequire("@ronomon/reed-solomon");

/**
 * Split `buffer` into Reed-Solomon shards, store each shard in IPFS via helia.blockstore.put(),
 * and return a manifest that matches your RSManifest type exactly.
 */
export async function encodeFileToShards(
  buffer: Buffer,
  opts: {
    dataShards: number;
    parityShards: number;
    filename: string;
    mimeType: string;
    helia: Helia;
  },
): Promise<{ manifest: RSManifest }> {
  const { dataShards, parityShards, filename, mimeType, helia } = opts;
  const totalShards = dataShards + parityShards;

  // 1) Create a ReedSolomon context
  const rsContext = ReedSolomon.create(dataShards, parityShards);

  // 2) Choose a shardSize (multiple of 8). Here: 64 KiB.
  const shardSize = 64 * 1024;

  // 3) Allocate dataBuffer (zero‐padded if needed)
  const originalFileSize = buffer.length;
  const dataBuffer = Buffer.alloc(shardSize * dataShards, 0);
  buffer.copy(
    /* target */ dataBuffer,
    /* targetOffset */ 0,
    /* sourceOffset */ 0,
    /* copyLength */ Math.min(buffer.length, dataBuffer.length),
  );

  // 4) Allocate an empty parityBuffer
  const parityBuffer = Buffer.alloc(shardSize * parityShards, 0);

  // 5) Build “sources” bitmask (first dataShards bits set)
  let sourcesBitmask = 0;
  for (let i = 0; i < dataShards; i++) {
    sourcesBitmask |= 1 << i;
  }

  // 6) Build “targets” bitmask (next parityShards bits)
  let targetsBitmask = 0;
  for (let j = 0; j < parityShards; j++) {
    targetsBitmask |= 1 << (dataShards + j);
  }

  // 7) Run ReedSolomon.encode (explicitly type `err` as Error|null)
  await new Promise<void>((resolve, reject) => {
    ReedSolomon.encode(
      rsContext,
      sourcesBitmask,
      targetsBitmask,
      dataBuffer,
      /* dataOffset */ 0,
      dataBuffer.byteLength,
      parityBuffer,
      /* parityOffset */ 0,
      parityBuffer.byteLength,
      (err: Error | null) => {
        if (err) reject(err);
        else resolve();
      },
    );
  });

  // 8) Now split dataBuffer into individual shards and store them via helia.blockstore.put
  const shards: RSShardInfo[] = [];

  for (let i = 0; i < dataShards; i++) {
    const slice = dataBuffer.slice(i * shardSize, (i + 1) * shardSize);

    // 8a) Hash with SHA-256
    const hash = await sha256.digest(Uint8Array.from(slice));

    // 8b) Wrap the digest into a CID (v1 + raw)
    const cid = CID.createV1(rawCodec.code, hash);

    // 8c) Store <CID, bytes> using helia.blockstore.put
    await (helia.blockstore as any).put(cid, Uint8Array.from(slice));

    shards.push({
      index: i,
      cid: cid.toString(),
      isParity: false,
    });
  }

  // 9) Do the same for parity shards
  for (let j = 0; j < parityShards; j++) {
    const slice = parityBuffer.slice(j * shardSize, (j + 1) * shardSize);
    const hash = await sha256.digest(Uint8Array.from(slice));
    const cid = CID.createV1(rawCodec.code, hash);

    await (helia.blockstore as any).put(cid, Uint8Array.from(slice));

    shards.push({
      index: dataShards + j,
      cid: cid.toString(),
      isParity: true,
    });
  }

  // 10) Build and return the manifest, exactly matching RSManifest
  const manifest: RSManifest = {
    filename,
    mimeType,
    originalFileSize,
    dataShards,
    parityShards,
    totalShards,
    shardSize,
    shards,
    createdAt: new Date().toISOString(),
  };

  return { manifest };
}

filename: packages/vinyl-peer-plugin-rs/src/utils/decoder.ts
filecontent:
import type { Helia } from "helia";
import { CID } from "multiformats/cid";
import type { RSManifest } from "../types.js";
import { createRequire } from "module";

const cjsRequire = createRequire(import.meta.url);
const ReedSolomon = cjsRequire("@ronomon/reed-solomon");

/**
 * Given an RSManifest, this function:
 *  1) Fetches each shard from IPFS via helia.blockstore.get()
 *  2) If any shards are missing, uses ReedSolomon.decode to reconstruct them
 *  3) Concatenates the first `dataShards` shards in index order to recover the original file
 */
export async function decodeShardsToFile(manifest: RSManifest, helia: Helia): Promise<Buffer> {
  const {
    dataShards,
    parityShards,
    totalShards,
    shardSize,
    originalFileSize,
    shards: shardInfos,
  } = manifest;

  // 1) Fetch each shard’s bytes (or leave undefined if missing)
  /** @type {Array<Buffer | undefined>} */
  const rawShards = new Array(totalShards).fill(undefined);

  for (let idx = 0; idx < totalShards; idx++) {
    // Find the shard record whose index === idx
    const record = shardInfos.find((s) => s.index === idx);
    if (!record) {
      rawShards[idx] = undefined;
      continue;
    }

    let cidObj;
    try {
      cidObj = CID.parse(record.cid);
    } catch {
      rawShards[idx] = undefined;
      continue;
    }

    try {
      // helia.blockstore.get returns a Uint8Array or null
      const chunkU8 = await (helia.blockstore as any).get(cidObj);
      if (chunkU8) {
        rawShards[idx] = Buffer.from(chunkU8);
      } else {
        rawShards[idx] = undefined;
      }
    } catch {
      rawShards[idx] = undefined;
    }
  }

  // 2) Determine missing shards
  const missing = rawShards.map((buf, i) => (buf == null ? i : null)).filter((i) => i !== null);

  if (missing.length === 0) {
    // No missing shards → just concatenate first dataShards
    const dataBufs = rawShards.slice(0, dataShards) as Buffer[];
    const full = Buffer.concat(dataBufs);
    // Trim to originalFileSize just in case of zero-padding
    return full.slice(0, originalFileSize);
  }

  // 3) Some shards missing → run ReedSolomon.decode
  const recoveredAll = await new Promise<Buffer>((resolve, reject) => {
    ReedSolomon.decode(
      rawShards,
      { dataShards, parityShards },
      (err: Error | null, recoveredBuffer: Buffer | undefined) => {
        if (err) return reject(err);
        if (!recoveredBuffer) {
          return reject(new Error("ReedSolomon.decode did not return a buffer"));
        }
        return resolve(recoveredBuffer);
      },
    );
  });

  // 4) recoveredAll is a Buffer of length totalShards * shardSize
  //    Slice out the first dataShards * shardSize bytes → the “data” portion
  const dataPortion = recoveredAll.slice(0, dataShards * shardSize);

  /** @type {Buffer[]} */
  const outputPieces = [];
  for (let i = 0; i < dataShards; i++) {
    const start = i * shardSize;
    const end = start + shardSize;
    outputPieces.push(dataPortion.slice(start, end));
  }

  // 5) Concatenate those pieces, then trim zero-padding to originalFileSize
  const combined = Buffer.concat(outputPieces);
  return combined.slice(0, originalFileSize);
}

filename: packages/vinyl-peer-plugin-rs/src/types.ts
filecontent:
/**
 * RSManifest: metadata needed to reassemble the original file.
 */
export interface RSShardInfo {
  index: number; // 0 .. (dataShards + parityShards - 1)
  cid: string; // IPFS/Helia CID for this single shard
  isParity: boolean; // true if this is one of the parity shards
}

export interface RSManifest {
  filename: string; // original filename (e.g. "track.mp3")
  mimeType: string; // original MIME (e.g. "audio/mpeg")
  originalFileSize: number; // exact byte length of the original file
  dataShards: number; // e.g. 6
  parityShards: number; // e.g. 3
  totalShards: number; // dataShards + parityShards
  shardSize: number; // size in bytes of each shard (all shards are equal length except the last data shard which may be padded)
  shards: RSShardInfo[]; // array of length `totalShards`
  createdAt: string; // timestamp when this manifest was created
}

filename: packages/vinyl-peer-plugin-rs/src/index.ts
filecontent:
export { ReedSolomonPlugin } from "./ReedSolomonPlugin.js";

filename: packages/vinyl-peer-plugin-rs/src/routes/recover.ts
filecontent:
import { Request, Response } from "express";
import type { PluginContext } from "vinyl-peer-protocol";
import type { Level } from "level";
import type { RSManifest } from "../types.js";
import { decodeShardsToFile } from "../utils/decoder.js";

/**
 * Returns an Express handler that:
 * - Expects `:id` to be the manifest ID in rsDb
 * - Fetches that manifest, runs RS decode, and returns the exact original bytes
 */
export default function recoverRoute(context: PluginContext, rsDb: Level<string, RSManifest>) {
  return async (req: Request, res: Response) => {
    const manifestId = req.params.id;

    let manifest: RSManifest;
    try {
      manifest = await rsDb.get(manifestId);
    } catch {
      res.status(404).json({ error: `Manifest "${manifestId}" not found` });
      return;
    }

    try {
      // decodeShardsToFile will fetch each shard from Helia, reconstruct, and return a Buffer
      const fileBuffer = await decodeShardsToFile(manifest, context.helia);

      // Set headers so browser/download clients know how to handle it
      res.setHeader("Content-Type", manifest.mimeType);
      res.setHeader("Content-Disposition", `attachment; filename="${manifest.filename}"`);
      res.send(fileBuffer);
    } catch (err) {
      console.error("[vinyl-rs] recover error:", err);
      res.status(500).json({ error: "Recovery/decode failed" });
    }
  };
}

filename: packages/vinyl-peer-plugin-rs/src/routes/upload.ts
filecontent:
import { Request, Response } from "express";
import type { PluginContext } from "vinyl-peer-protocol";
import type { Level } from "level";
import { encodeFileToShards } from "../utils/encoder.js";
import type { RSManifest } from "../types.js";

/**
 * Returns an Express handler that:
 * - Expects `req.file.buffer` (via multer) containing the raw file
 * - Reads optional `dataShards` and `parityShards` from req.body
 * - Calls encodeFileToShards → writes the manifest into rsDb
 * - Responds with { id, shards: [ { index, cid, isParity } ] }
 */
export default function uploadRoute(context: PluginContext, rsDb: Level<string, RSManifest>) {
  return async (req: Request, res: Response) => {
    // 1) Multer has populated `req.file`
    const file = req.file;
    if (!file || !file.buffer) {
      res.status(400).json({ error: "Missing file (field name must be 'file')" });
      return;
    }

    // 2) Read optional shard counts from the form
    const dataShards = parseInt(req.body.dataShards, 10) || 6;
    const parityShards = parseInt(req.body.parityShards, 10) || 3;

    try {
      // 3) Encode into shards (this pins each shard into Helia internally)
      const { manifest } = await encodeFileToShards(file.buffer, {
        dataShards,
        parityShards,
        filename: file.originalname,
        mimeType: file.mimetype || "application/octet-stream",
        helia: context.helia,
      });

      // 4) Create a manifest ID and store it in LevelDB
      const manifestId = `${context.nodeId}-${Date.now()}`;
      await rsDb.put(manifestId, manifest);

      // 5) Return ID + list of shards
      res.json({
        id: manifestId,
        shards: manifest.shards,
      });
    } catch (err) {
      console.error("[vinyl-rs] upload error:", err);
      res.status(500).json({ error: "Upload/encoding failed" });
    }
  };
}

filename: packages/vinyl-peer-plugin-auto-replication/tsconfig.esm.json
filecontent:
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "module": "ESNext",                // produce ESM
    "target": "ES2020",                // or whatever target you prefer
    "outDir": "dist/esm",              // everything goes under dist/esm
    "declaration": true,               // emit .d.ts files
    "declarationDir": "dist/esm",      // put .d.ts next to .js
    "strict": true,
    "esModuleInterop": true,
    "moduleResolution": "node",
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}

filename: packages/vinyl-peer-plugin-auto-replication/package.json
filecontent:
{
  "name": "vinyl-peer-plugin-auto-replication",
  "version": "0.0.1",
  "authors": [
    "KDLabs"
  ],
  "type": "module",
  "main": "dist/cjs/index.js",
  "module": "dist/esm/index.js",
  "types": "dist/esm/index.d.ts",
  "exports": {
    "import": "./dist/esm/index.js",
    "require": "./dist/cjs/index.js"
  },
  "scripts": {
    "build:esm": "tsc -p tsconfig.esm.json",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build": "rimraf dist && npm run build:esm && npm run build:cjs",
    "test": "vitest"
  },
  "dependencies": {
    "@types/geoip-lite": "^1.4.4",
    "express": "^5.1.0",
    "geoip-lite": "^1.4.10",
    "level": "^10.0.0",
    "vinyl-peer-protocol": "workspace:*"
  },
  "devDependencies": {
    "@types/express": "^5.0.2",
    "@types/node": "^18.7.23",
    "typescript": "^5.7.3",
    "vitest": "^3.0.5"
  }
}

filename: packages/vinyl-peer-plugin-auto-replication/tsconfig.cjs.json
filecontent:
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "module": "CommonJS",     // produce CJS
    "target": "ES2020",       
    "outDir": "dist/cjs",     // everything goes under dist/cjs
    "declaration": false      // we don’t need .d.ts here (we already emitted them under dist/esm)
  },
  "include": ["src/**/*"]
}

filename: packages/vinyl-peer-plugin-auto-replication/src/AutoReplicationPlugin.ts
filecontent:
import {
  BasePlugin,
  PluginCapabilities,
  PluginContext,
  VinylPeerPlugin,
} from "vinyl-peer-protocol";
import { Level } from "level";
import path from "path";
import express from "express";
import geoip from "geoip-lite";
import type { DemandRecord, RegionConfig, AutoReplicationOptions } from "./types.js";
import { DemandMonitor } from "./utils/monitor.js";
import { ReplicationBalancer } from "./utils/balancer.js";
import statusRoute from "./routes/status.js";
import overrideRoute from "./routes/override.js";

/**
 * AutoReplicationPlugin:
 * - Watches “fileDownloaded” events → increments demand.
 * - When “hot,” auto-pins to peers, optionally geo‐aware.
 * - Emits “archiveRequested” for downstream bridge plugins.
 * - Exposes HTTP endpoints for status, override, geo toggles, region config.
 */
export class AutoReplicationPlugin extends BasePlugin implements VinylPeerPlugin {
  protected context!: PluginContext;

  private demandDb!: Level<string, DemandRecord>;
  private monitor!: DemandMonitor;
  private balancer!: ReplicationBalancer;

  private geoAware: boolean;
  private regionConfig: RegionConfig;
  private localRegion: string;
  private hotThreshold: number;
  private defaultMinReplicas: number;

  constructor(opts: AutoReplicationOptions = {}) {
    super();
    this.geoAware = opts.geoAware ?? false;
    this.regionConfig = opts.defaultRegionConfig ?? {
      NA: 3,
      EU: 2,
      AS: 1,
      AF: 1,
      SA: 1,
      OC: 1,
      AN: 1,
    };
    this.hotThreshold = opts.hotThreshold ?? 10;
    this.defaultMinReplicas = opts.defaultMinReplicas ?? 3;
    this.localRegion = "NA"; // will be updated in initialize()
  }

  getCapabilities(): PluginCapabilities {
    return {
      name: "vinyl-peer-plugin-auto-replication",
      version: "0.1.0",
      protocols: [],
      capabilities: ["storage"],
      permissions: {
        accessFiles: true,
        useNetwork: true,
        modifyPeers: false,
        exposeHttp: true,
      },
    };
  }

  async initialize(context: PluginContext): Promise<boolean> {
    const ok = await super.initialize(context);
    if (!ok) return false;
    this.context = context;

    // 1) Determine this node’s region via GeoIP
    this.localRegion = this.determineLocalRegion();

    // 2) LevelDB for demand counts (optional persistence)
    const folder = path.join(process.cwd(), "demand-records");
    this.demandDb = new Level<string, DemandRecord>(folder, { valueEncoding: "json" });

    // 3) Create DemandMonitor & ReplicationBalancer
    this.monitor = new DemandMonitor(this.hotThreshold);
    this.balancer = new ReplicationBalancer(this.context, this.defaultMinReplicas);

    // 4) When a "hot" event fires, decide how to pin and then emit archive request
    this.monitor.onHot(async (cid: string) => {
      try {
        if (this.geoAware) {
          const desired = this.regionConfig[this.localRegion] ?? this.defaultMinReplicas;
          const currentCount = this.balancer.countLocalReplicas(cid, this.localRegion);
          if (currentCount < desired) {
            await this.balancer.maybePinInRegion(cid, this.localRegion, this.regionConfig);
          }
        } else {
          await this.balancer.maybePin(cid);
        }
      } catch (err) {
        console.error("[AutoReplication] pin attempt failed:", err);
      }

      // 5) Emit an archiveRequested event (bridges pick this up)
      this.context.emit("archiveRequested", {
        source: "auto-replication",
        payload: { cid },
      });
    });

    // 6) Listen to core's fileDownloaded events to track demand
    this.context.onEvent((evt, envelope) => {
      if (evt === "fileDownloaded") {
        const cid = envelope.payload as string;
        this.monitor.recordDownload(cid);
      }
    });

    return true;
  }

  async start(): Promise<void> {
    await super.start();
    // No extra work needed
  }

  async stop(): Promise<void> {
    await this.demandDb.close();
    await super.stop();
  }

  setupProtocols(): void {
    // No libp2p protocols
  }

  async handleProtocol(_protocol: string, _stream: any, _peerId: string): Promise<void> {
    // Not used
  }

  getHttpNamespace(): string {
    return "/api/replicate";
  }

  getHttpRouter(): express.Router {
    const router = express.Router();

    // GET /api/replicate/status
    router.get("/status", statusRoute(this.balancer));

    // POST /api/replicate/override
    router.post("/override", overrideRoute(this.balancer));

    // Geo‐aware toggles and region config
    router.get("/geo/status", (_req, res) => {
      res.json({
        geoAware: this.geoAware,
        localRegion: this.localRegion,
        regionConfig: this.regionConfig,
        hotThreshold: this.hotThreshold,
        defaultMinReplicas: this.defaultMinReplicas,
      });
    });

    router.post("/geo/on", (_req, res) => {
      this.geoAware = true;
      res.json({ geoAware: true, message: "Geo‐aware replication is ON" });
    });
    router.post("/geo/off", (_req, res) => {
      this.geoAware = false;
      res.json({ geoAware: false, message: "Geo‐aware replication is OFF" });
    });

    // GET /api/replicate/regions → return regionConfig
    router.get("/regions", (_req, res) => {
      res.json({ regionConfig: this.regionConfig });
    });

    // POST /api/replicate/regions → update regionConfig
    router.post("/regions", (req, res) => {
      const newConfig: RegionConfig = req.body.regionConfig;
      if (typeof newConfig !== "object" || Array.isArray(newConfig)) {
        res.status(400).json({ error: "Invalid regionConfig format" });
        return;
      }
      this.regionConfig = { ...this.regionConfig, ...newConfig };
      res.json({ regionConfig: this.regionConfig, message: "Region configuration updated." });
    });

    return router;
  }

  /**
   * Determine this node's region code by using geoip-lite's lookup.
   * We use the two‐letter country code (e.g. "US") and map to a continent key
   * if available; otherwise default to "NA".
   */
  private determineLocalRegion(): string {
    try {
      const addrs = this.context.libp2p.getMultiaddrs?.() || [];
      for (const ma of addrs) {
        // Example multiaddr: "/ip4/203.0.113.5/tcp/4001"
        const str = ma.toString();
        const parts = str.split("/");
        const idx = parts.findIndex((p: string) => p === "ip4" || p === "ip6");
        if (idx !== -1 && parts.length > idx + 1) {
          const ip = parts[idx + 1];
          const geo = geoip.lookup(ip);
          if (geo?.country) {
            const countryCode = geo.country; // e.g. "US", "FR", "CN"
            // Map a few common country→continent codes:
            const countryToContinent: Record<string, string> = {
              US: "NA",
              CA: "NA",
              MX: "NA",
              BR: "SA",
              AR: "SA",
              GB: "EU",
              FR: "EU",
              DE: "EU",
              CN: "AS",
              JP: "AS",
              IN: "AS",
              AU: "OC",
              ZA: "AF",
              EG: "AF",
            };
            return countryToContinent[countryCode] ?? "NA";
          }
        }
      }
    } catch {
      // ignore lookup errors
    }
    return "NA";
  }
}

filename: packages/vinyl-peer-plugin-auto-replication/src/utils/balancer.ts
filecontent:
import type { PluginContext } from "vinyl-peer-protocol";
import geoip from "geoip-lite";

/**
 * ReplicationBalancer:
 * - Chooses which peer to pin a “hot” CID to.
 * - Keeps track (in‐memory) of which peers have pinned which CIDs.
 *
 * Production tweaks:
 *  - Concurrency‐safe (operations atomic on in‐memory Set)
 *  - Configurable defaultMinReplicas and per‐region targets
 */
export class ReplicationBalancer {
  private pinnedMap: Map<string, Set<string>> = new Map(); // cid → set(peerIds)
  private defaultMinReplicas: number;

  constructor(
    private context: PluginContext,
    defaultMinReplicas: number = 3,
  ) {
    this.defaultMinReplicas = defaultMinReplicas;
  }

  /**
   * Default “maybePin” logic (non‐geo‐aware):
   * - If fewer than `defaultMinReplicas` total replicas exist, pick a random peer to pin.
   */
  async maybePin(cid: string) {
    const activePeers = Array.from(this.context.peers.keys());
    if (activePeers.length === 0) return;

    const current = this.pinnedMap.get(cid) || new Set<string>();
    if (current.size < this.defaultMinReplicas) {
      const candidates = activePeers.filter((p) => !current.has(p));
      if (candidates.length > 0) {
        const peerId = candidates[Math.floor(Math.random() * candidates.length)];
        // Use this.emit() so that source is set to this plugin’s name
        this.emit("replicate:pinRequest", { cid, targetPeer: peerId });
        current.add(peerId);
        this.pinnedMap.set(cid, current);
      }
    }
  }

  /**
   * Geo‐aware “maybePinInRegion”:
   * - Ensures that each region has at least regionConfig[region] replicas.
   * - If this region is under‐replicated, pick a peer from that region.
   */
  async maybePinInRegion(
    cid: string,
    region: string,
    regionConfig: { [continent: string]: number },
  ) {
    const desired = regionConfig[region] ?? this.defaultMinReplicas;
    const current = this.pinnedMap.get(cid) || new Set<string>();

    // Count how many peers in this region already pinned
    let countInRegion = 0;
    for (const peerId of current) {
      const peerInfo = this.context.peers.get(peerId);
      if (!peerInfo) continue;
      const peerRegion = this.lookupContinent(peerInfo.address);
      if (peerRegion === region) {
        countInRegion++;
      }
    }

    if (countInRegion < desired) {
      // Find candidates in this region that haven’t pinned
      const candidates = Array.from(this.context.peers.entries())
        .filter(([peerId, peerInfo]) => {
          const peerRegion = this.lookupContinent(peerInfo.address);
          return peerRegion === region && !current.has(peerId);
        })
        .map(([peerId]) => peerId);

      if (candidates.length > 0) {
        const peerId = candidates[Math.floor(Math.random() * candidates.length)];
        this.emit("replicate:pinRequest", { cid, targetPeer: peerId });
        current.add(peerId);
        this.pinnedMap.set(cid, current);
      }
    }
  }

  /**
   * Force‐pin or unpin (override) a given CID on this node.
   */
  async override(cid: string, action: "pin" | "unpin") {
    if (!this.pinnedMap.has(cid)) {
      this.pinnedMap.set(cid, new Set<string>());
    }
    const current = this.pinnedMap.get(cid)!;
    if (action === "pin") {
      await this.context.pinFile(cid);
      current.add(this.context.nodeId);
    } else {
      await this.context.unpinFile(cid);
      current.delete(this.context.nodeId);
    }
    this.pinnedMap.set(cid, current);
  }

  /**
   * Return status: how many replicas exist per CID and which peers have pinned them.
   */
  getStatus(): { [cid: string]: { replicaCount: number; peers: string[] } } {
    const result: Record<string, { replicaCount: number; peers: string[] }> = {};
    for (const [cid, peerSet] of this.pinnedMap.entries()) {
      result[cid] = { replicaCount: peerSet.size, peers: Array.from(peerSet) };
    }
    return result;
  }

  /**
   * Count how many replicas of a CID exist in a given region (based on pinnedMap).
   */
  countLocalReplicas(cid: string, region: string): number {
    const current = this.pinnedMap.get(cid) || new Set<string>();
    let count = 0;
    for (const peerId of current) {
      const peerInfo = this.context.peers.get(peerId);
      if (!peerInfo) continue;
      const peerRegion = this.lookupContinent(peerInfo.address);
      if (peerRegion === region) {
        count++;
      }
    }
    return count;
  }

  /**
   * Helper: given an IP address string, return a continent code like "NA", "EU", etc.
   * Maps lookup(country) → continent by using a small mapping table.
   * Defaults to "NA" if unknown.
   */
  private lookupContinent(ip: string): string {
    const geo = geoip.lookup(ip);
    if (!geo?.country) {
      return "NA";
    }
    const countryCode = geo.country; // e.g., "US", "FR", "CN"
    const countryToContinent: Record<string, string> = {
      US: "NA",
      CA: "NA",
      MX: "NA",
      BR: "SA",
      AR: "SA",
      GB: "EU",
      FR: "EU",
      DE: "EU",
      CN: "AS",
      JP: "AS",
      IN: "AS",
      AU: "OC",
      ZA: "AF",
      EG: "AF",
      // add more mappings as needed
    };
    return countryToContinent[countryCode] ?? "NA";
  }

  /**
   * Emit a replication event. Wraps context.emit to set source automatically.
   */
  private emit(event: string, payload: any) {
    // Use BasePlugin.emit signature: { source: <pluginName>, payload }
    // But since ReplicationBalancer is not itself a plugin, include a generic source
    this.context.emit(event, { source: "auto-replication", payload });
  }
}

filename: packages/vinyl-peer-plugin-auto-replication/src/utils/monitor.ts
filecontent:
import type { DemandRecord } from "../types.js";

/**
 * DemandMonitor:
 * - Tracks how many times each CID is downloaded.
 * - Emits “hot” event when count reaches threshold.
 *
 * Production tweaks:
 *  - Batched persistence (optional)
 *  - In‐memory only, but could be linked to a LevelDB for crash recovery.
 */
export class DemandMonitor {
  private counts: Map<string, DemandRecord> = new Map();
  private hotThreshold: number;
  private listeners: ((cid: string) => void)[] = [];

  constructor(hotThreshold: number = 10) {
    this.hotThreshold = hotThreshold;
  }

  recordDownload(cid: string) {
    const now = new Date().toISOString();
    const rec = this.counts.get(cid) || { cid, count: 0, lastRequested: now };
    rec.count += 1;
    rec.lastRequested = now;
    this.counts.set(cid, rec);

    if (rec.count === this.hotThreshold) {
      this.emitHot(cid);
    }
  }

  private emitHot(cid: string) {
    for (const cb of this.listeners) {
      try {
        cb(cid);
      } catch (err) {
        console.error("[AutoReplication][monitor] listener error:", err);
      }
    }
  }

  onHot(callback: (cid: string) => void) {
    this.listeners.push(callback);
  }

  getDemand(cid: string): DemandRecord | undefined {
    return this.counts.get(cid);
  }
}

filename: packages/vinyl-peer-plugin-auto-replication/src/types.ts
filecontent:
/**
 * Records download frequencies per shard‐CID (or manifest‐CID).
 */
export interface DemandRecord {
  cid: string;
  count: number;
  lastRequested: string; // ISO timestamp
}

/**
 * Override entry: force‐pin or remove pin on a given CID.
 */
export interface OverrideEntry {
  cid: string;
  action: "pin" | "unpin";
  timestamp: string;
}

/**
 * Status response: returns how many replicas exist for each hot CID,
 * and which peers have pinned them.
 */
export interface ReplicationStatus {
  cid: string;
  replicaCount: number;
  peers: string[];
}

/**
 * Optional region configuration: desired number of replicas per continent.
 */
export interface RegionConfig {
  [continent: string]: number;
}

/**
 * Options for AutoReplicationPlugin:
 */
export interface AutoReplicationOptions {
  hotThreshold?: number;
  geoAware?: boolean;
  defaultRegionConfig?: RegionConfig;
  defaultMinReplicas?: number;
}

filename: packages/vinyl-peer-plugin-auto-replication/src/index.ts
filecontent:
export * from "./AutoReplicationPlugin.js";

filename: packages/vinyl-peer-plugin-auto-replication/src/routes/override.ts
filecontent:
import { Router, Request, Response } from "express";
import type { ReplicationBalancer } from "../utils/balancer.js";

/**
 * POST /api/replicate/override
 * Body: { cid: string, action: "pin" | "unpin" }
 */
export default function overrideRoute(balancer: ReplicationBalancer) {
  return async (req: Request, res: Response) => {
    const { cid, action } = req.body;
    if (!cid || (action !== "pin" && action !== "unpin")) {
      res.status(400).json({ error: "Invalid payload" });
      return;
    }
    try {
      await balancer.override(cid, action);
      res.json({ success: true });
    } catch (err) {
      console.error("[auto-replication] override error:", err);
      res.status(500).json({ error: "Override failed" });
    }
  };
}

filename: packages/vinyl-peer-plugin-auto-replication/src/routes/status.ts
filecontent:
import { Router, Request, Response } from "express";
import type { ReplicationStatus } from "../types.js";
import type { ReplicationBalancer } from "../utils/balancer.js";

/**
 * GET /api/replicate/status
 * → Return JSON array of { cid, replicaCount, peers }
 */
export default function statusRoute(balancer: ReplicationBalancer) {
  return (_req: Request, res: Response) => {
    const statusMap = balancer.getStatus();
    const response: ReplicationStatus[] = Object.entries(statusMap).map(
      ([cid, { replicaCount, peers }]) => ({ cid, replicaCount, peers }),
    );
    res.json(response);
  };
}

filename: packages/vinyl-peer-plugin-analytics/tsconfig.esm.json
filecontent:
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "module": "ESNext",                // produce ESM
    "target": "ES2020",                // or whatever target you prefer
    "outDir": "dist/esm",              // everything goes under dist/esm
    "declaration": true,               // emit .d.ts files
    "declarationDir": "dist/esm",      // put .d.ts next to .js
    "strict": true,
    "esModuleInterop": true,
    "moduleResolution": "node",
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}

filename: packages/vinyl-peer-plugin-analytics/package.json
filecontent:
{
  "name": "vinyl-peer-plugin-analytics",
  "version": "0.0.1",
  "authors": [
    "KDLabs"
  ],
  "type": "module",
  "main": "dist/cjs/index.js",
  "module": "dist/esm/index.js", 
  "types": "dist/esm/index.d.ts",
  "exports": {
    "import": "./dist/esm/index.js",
    "require": "./dist/cjs/index.js"
  },
  "scripts": {
    "build:esm": "tsc -p tsconfig.esm.json",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build": "rimraf dist && npm run build:esm && npm run build:cjs",
    "test": "vitest"
  },
  "dependencies": {
    "express": "^4.18.2",
    "vinyl-peer-protocol": "workspace:*"
  },
  "devDependencies": {
    "@types/express": "^5.0.2",
    "@types/node": "^18.7.23",
    "typescript": "^5.7.3",
    "vitest": "^3.0.5"
  }
}

filename: packages/vinyl-peer-plugin-analytics/tsconfig.cjs.json
filecontent:
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "module": "CommonJS",     // produce CJS
    "target": "ES2020",       
    "outDir": "dist/cjs",     // everything goes under dist/cjs
    "declaration": false      // we don’t need .d.ts here (we already emitted them under dist/esm)
  },
  "include": ["src/**/*"]
}

filename: packages/vinyl-peer-plugin-analytics/src/AnalyticsPlugin.ts
filecontent:
import express, { Request, Response, Router } from "express";
import {
  BasePlugin,
  PluginCapabilities,
  PluginContext,
  VinylPeerPlugin,
} from "vinyl-peer-protocol";
import { FileInfo } from "vinyl-peer-protocol";
import { AnalyticsSnapshot } from "./types.js";

export class AnalyticsPlugin extends BasePlugin implements VinylPeerPlugin {
  protected context!: PluginContext;
  private snapshotIntervalMs: number = 60000; // 1 minute
  private intervalHandle: NodeJS.Timeout | null = null;
  private lastSnapshot: AnalyticsSnapshot | null = null;

  constructor(snapshotIntervalMs?: number) {
    super();
    if (snapshotIntervalMs) {
      this.snapshotIntervalMs = snapshotIntervalMs;
    }
  }

  /** Identify plugin; no libp2p protocols needed here. */
  getCapabilities(): PluginCapabilities {
    return {
      name: "vinyl-peer-plugin-analytics",
      version: "0.0.1",
      protocols: [], // No custom libp2p protocols
      capabilities: ["analytics"],
      fileTypes: [],
      permissions: {
        accessFiles: true,
        useNetwork: false,
        modifyPeers: false,
        exposeHttp: true,
      },
    };
  }

  /** Standard initialize; store context. */
  async initialize(context: PluginContext): Promise<boolean> {
    const ok = await super.initialize(context);
    if (!ok) return false;
    this.context = context;
    return true;
  }

  /** Start periodic snapshotting. */
  async start(): Promise<void> {
    if (!this.context) {
      throw new Error("AnalyticsPlugin: missing context");
    }
    // Immediately take one snapshot
    this.takeSnapshot();
    // Then schedule periodic snapshots
    this.intervalHandle = setInterval(() => {
      this.takeSnapshot();
    }, this.snapshotIntervalMs);
    this.isStarted = true;
  }

  /** Stop the interval. */
  async stop(): Promise<void> {
    if (this.intervalHandle) {
      clearInterval(this.intervalHandle);
      this.intervalHandle = null;
    }
    this.isStarted = false;
    await super.stop();
  }

  /** No libp2p protocols to register. */
  setupProtocols(): void {
    // no-op
  }

  /** No incoming protocol streams to handle. */
  async handleProtocol(protocol: string, stream: any, peerId: string): Promise<void> {
    // no-op
  }

  /**
   * Periodically create an AnalyticsSnapshot and emit it.
   */
  private takeSnapshot(): void {
    if (!this.context) return;
    const totalPeers = this.context.peers.size;
    const totalConnectedPeers = Array.from(this.context.peers.values()).filter(
      (p) => p.status === "connected",
    ).length;
    const totalFiles = this.context.files.size;
    const totalPinCount = Array.from(this.context.files.values()).filter(
      (f) => f.pinned === true,
    ).length;

    const snapshot: AnalyticsSnapshot = {
      timestamp: new Date().toISOString(),
      totalPeers,
      totalConnectedPeers,
      totalFiles,
      totalPinCount,
    };

    this.lastSnapshot = snapshot;
    this.emit("analyticsSnapshot", snapshot);
  }

  /**
   * Return the HTTP namespace for analytics routes.
   */
  getHttpNamespace(): string {
    return "/api/analytics";
  }

  /**
   * Return an Express.Router exposing analytics endpoints:
   *  - GET /api/analytics/snapshot
   *  - GET /api/analytics/top-file-types
   */
  getHttpRouter(): Router {
    const router = express.Router();

    // GET /api/analytics/snapshot → returns last snapshot
    router.get("/snapshot", (req: Request, res: Response) => {
      try {
        if (!this.lastSnapshot) {
          res.status(404).json({ error: "No snapshot available yet" });
          return;
        }
        res.json({ snapshot: this.lastSnapshot });
      } catch (err: any) {
        res.status(500).json({ error: err.message });
      }
    });

    // GET /api/analytics/top-file-types → returns top 10 file types by count
    router.get("/top-file-types", (req: Request, res: Response) => {
      try {
        if (!this.context) {
          res.status(500).json({ error: "AnalyticsPlugin: context not available" });
          return;
        }
        const typeCounts: Map<string, number> = new Map();
        for (const file of Array.from(this.context.files.values())) {
          const t = file.type;
          typeCounts.set(t, (typeCounts.get(t) || 0) + 1);
        }
        const sorted = Array.from(typeCounts.entries())
          .map(([type, count]) => ({ type, count }))
          .sort((a, b) => b.count - a.count)
          .slice(0, 10);
        res.json({ topFileTypes: sorted });
      } catch (err: any) {
        res.status(500).json({ error: err.message });
      }
    });

    return router;
  }
}

filename: packages/vinyl-peer-plugin-analytics/src/types.ts
filecontent:
/**
 * AnalyticsSnapshot: A periodic snapshot of overall node metrics.
 */
export interface AnalyticsSnapshot {
  timestamp: string;
  totalPeers: number;
  totalConnectedPeers: number;
  totalFiles: number;
  totalPinCount: number;
}

/**
 * TopFileType: The top N file types stored, with counts.
 */
export interface TopFileType {
  type: string;
  count: number;
}

/**
 * AnalyticsStats: Combined analytics results returned over HTTP.
 */
export interface AnalyticsStats {
  snapshot: AnalyticsSnapshot;
  topFileTypes: TopFileType[];
  pinnedFileCount: number;
  connectedMusicPeers: number;
}

filename: packages/vinyl-peer-plugin-analytics/src/index.ts
filecontent:
export * from "./types.js";
export * from "./AnalyticsPlugin.js";

filename: packages/vinyl-peer-protocol/tsconfig.esm.json
filecontent:
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "module": "ESNext",                // produce ESM
    "target": "ES2020",                // or whatever target you prefer
    "outDir": "dist/esm",              // everything goes under dist/esm
    "declaration": true,               // emit .d.ts files
    "declarationDir": "dist/esm",      // put .d.ts next to .js
    "strict": true,
    "esModuleInterop": true,
    "moduleResolution": "node",
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}

filename: packages/vinyl-peer-protocol/package.json
filecontent:
{
  "name": "vinyl-peer-protocol",
  "version": "0.0.1",
  "authors": [
    "KDLabs"
  ],
  "type": "module",
  "main": "dist/cjs/index.js",
  "module": "dist/esm/index.js",
  "types": "dist/esm/index.d.ts",
  "exports": {
    "import": "./dist/esm/index.js",
    "require": "./dist/cjs/index.js"
  },
  "scripts": {
    "build:esm": "tsc -p tsconfig.esm.json",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build": "rimraf dist && npm run build:esm && npm run build:cjs",
    "test": "vitest"
  },
  "dependencies": {
    "@chainsafe/libp2p-gossipsub": "^14.1.1",
    "@chainsafe/libp2p-noise": "^16.1.3",
    "@chainsafe/libp2p-yamux": "^7.0.1",
    "@helia/unixfs": "^5.0.3",
    "@hookform/resolvers": "^3.9.0",
    "@libp2p/bootstrap": "^11.0.20",
    "@libp2p/circuit-relay-v2": "^3.2.14",
    "@libp2p/identify": "^3.0.32",
    "@libp2p/kad-dht": "^15.1.2",
    "@libp2p/mdns": "^11.0.20",
    "@libp2p/noise": "^12.0.1",
    "@libp2p/ping": "^2.0.32",
    "@libp2p/tcp": "^10.1.13",
    "@libp2p/webrtc": "^5.2.15",
    "@libp2p/websockets": "^9.2.13",
    "@ronomon/reed-solomon": "^6.0.0",
    "blockstore-level": "^2.0.3",
    "cors": "^2.8.5",
    "crypto-js": "^4.2.0",
    "express": "^5.1.0",
    "express-rate-limit": "^7.5.0",
    "helia": "^5.4.2",
    "helmet": "^8.1.0",
    "level": "^10.0.0",
    "libp2p": "^2.8.8",
    "mime-types": "^2.1.34",
    "multer": "^1.4.5-lts.1",
    "tsx": "^4.19.4",
    "uuid": "^11.1.0",
    "zod": "^3.25.46"
  },
  "devDependencies": {
    "@types/cors": "^2.8.12",
    "@types/mime-types": "^2.1.0",
    "@types/multer": "^1.4.7",
    "@types/crypto-js": "^4.0.3",
    "@types/express": "^5.0.2",
    "@types/node": "^18.7.23",
    "rimraf": "^5.0.0",
    "typescript": "^5.7.3",
    "vitest": "^3.0.5"
  }
}

filename: packages/vinyl-peer-protocol/tsconfig.cjs.json
filecontent:
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "module": "ESNext",     // produce CJS
    "target": "ES2020",       
    "outDir": "dist/cjs",     // everything goes under dist/cjs
    "declaration": false      // we don’t need .d.ts here (we already emitted them under dist/esm)
  },
  "include": ["src/**/*"]
}

filename: packages/vinyl-peer-protocol/src/PluginManager.ts
filecontent:
import type { VinylPeerPlugin, PluginContext } from "./PluginInterface.js";
import type { PeerInfo, FileInfo, NetworkFileInfo, UploadFile } from "./types.js";

export class PluginManager {
  private plugins: Map<string, VinylPeerPlugin> = new Map();
  private context: PluginContext | null = null;
  /**
   * Maps a protocol string ("/foo/1.0.0") → the plugin that registered it.
   */
  private protocolHandlers: Map<string, VinylPeerPlugin> = new Map();

  setContext(context: PluginContext): void {
    this.context = context;
  }

  /**
   * Register a plugin:
   * 1) plugin.initialize(context)
   * 2) For each protocol in plugin.getCapabilities().protocols → libp2p.handle(...)
   *    but only if no‐one else has already bound that protocol
   * 3) Enforce protocol validation and size‐limit transforms
   * 4) Add plugin to this.plugins
   */
  async registerPlugin(plugin: VinylPeerPlugin): Promise<boolean> {
    if (!this.context) {
      throw new Error("Plugin context not set");
    }

    const caps = plugin.getCapabilities();
    console.log(`PluginManager: initializing plugin "${caps.name}" v${caps.version}…`);

    // 1) Initialize plugin
    const ok = await plugin.initialize(this.context);
    if (!ok) {
      console.error(`PluginManager: plugin "${caps.name}" failed to initialize`);
      return false;
    }

    // 2) Register protocol handlers (check for collisions)
    if (caps.protocols && this.context.libp2p) {
      for (const protocol of caps.protocols) {
        if (this.protocolHandlers.has(protocol)) {
          console.warn(
            `PluginManager: protocol "${protocol}" already registered, skipping for plugin "${plugin.getCapabilities().name}"`,
          );
          continue;
        }
        this.protocolHandlers.set(protocol, plugin);

        // Attach a wrapped handler → validate protocol and peer identity
        this.context.libp2p.handle(protocol, async ({ stream, connection }: any) => {
          try {
            if (plugin.identifyPeer) {
              const verified = await plugin.identifyPeer(connection.remotePeer.toString());
              if (!verified) {
                console.warn(
                  `PluginManager: peer ${connection.remotePeer.toString()} failed identification for protocol ${protocol}`,
                );
                return;
              }
            }

            const MAX_MESSAGE_SIZE = 1 * 1024 * 1024; // 1 MB
            const sizeLimiter = new stream.Transform({
              transform(
                chunk: Buffer,
                _: any,
                callback: (error?: Error | null, data?: Buffer) => void,
              ) {
                if (chunk.length > MAX_MESSAGE_SIZE) {
                  callback(new Error("Message too large"));
                } else {
                  callback(null, chunk);
                }
              },
            });
            const limitedStream = stream.pipe(sizeLimiter);

            await plugin.handleProtocol(protocol, limitedStream, connection.remotePeer.toString());
          } catch (err) {
            console.error(
              `PluginManager: error in handleProtocol("${protocol}") for plugin "${caps.name}"`,
              err,
            );
          }
        });
        console.log(
          `PluginManager: bound protocol "${protocol}" → plugin "${caps.name}" (no collisions).`,
        );
      }
    }

    this.plugins.set(caps.name, plugin);
    return true;
  }

  async unregisterPlugin(pluginName: string): Promise<boolean> {
    try {
      const plugin = this.plugins.get(pluginName);
      if (!plugin) {
        console.warn(`PluginManager: plugin "${pluginName}" not found`);
        return false;
      }

      const caps = plugin.getCapabilities();

      await plugin.stop();

      for (const protocol of caps.protocols) {
        this.protocolHandlers.delete(protocol);
        if (this.context?.libp2p) {
          this.context.libp2p.unhandle(protocol);
        }
      }

      this.plugins.delete(pluginName);
      console.log(`PluginManager: plugin "${pluginName}" unregistered`);
      return true;
    } catch (err) {
      console.error(`PluginManager: error unregistering "${pluginName}"`, err);
      return false;
    }
  }

  getPlugin(pluginName: string): VinylPeerPlugin | undefined {
    return this.plugins.get(pluginName);
  }

  getAllPlugins(): VinylPeerPlugin[] {
    return Array.from(this.plugins.values());
  }

  async startAllPlugins(): Promise<void> {
    console.log("PluginManager: starting all plugins…");
    for (const [name, plugin] of this.plugins.entries()) {
      try {
        // Placeholder: enforce resource quotas (not fully implemented here)
        console.log(`Enforcing resource quotas for plugin "${name}"...`);
        await plugin.start();
        console.log(`PluginManager: plugin "${name}" started`);
      } catch (err) {
        console.error(`PluginManager: error starting plugin "${name}"`, err);
      }
    }
  }

  async stopAllPlugins(): Promise<void> {
    console.log("PluginManager: stopping all plugins…");

    this.protocolHandlers.clear();

    for (const [name, plugin] of this.plugins.entries()) {
      try {
        await plugin.stop();
        console.log(`PluginManager: plugin "${name}" stopped`);
      } catch (err) {
        console.error(`PluginManager: error stopping plugin "${name}"`, err);
      }
    }

    this.plugins.clear();
  }

  /**
   * Let each plugin enhance file‐metadata.
   */
  async enhanceFileMetadata(file: UploadFile): Promise<any> {
    let aggregated: any = {};
    for (const plugin of this.plugins.values()) {
      if (plugin.enhanceMetadata) {
        try {
          const md = await plugin.enhanceMetadata(file);
          aggregated = { ...aggregated, ...md };
        } catch (err) {
          console.error("PluginManager: error in enhanceMetadata()", err);
        }
      }
    }
    return aggregated;
  }

  /**
   * Let each plugin run `searchFiles(...)` and concatenate all results.
   */
  async searchFiles(query: any): Promise<NetworkFileInfo[]> {
    let results: NetworkFileInfo[] = [];
    for (const plugin of this.plugins.values()) {
      if (plugin.searchFiles) {
        try {
          const pluginResults = await plugin.searchFiles(query);
          results = results.concat(pluginResults);
        } catch (err) {
          console.error("PluginManager: error in searchFiles()", err);
        }
      }
    }
    return results;
  }

  /**
   * Let each plugin run `getRecommendations(...)` and concatenate results.
   */
  async getRecommendations(basedOnCid: string): Promise<NetworkFileInfo[]> {
    let results: NetworkFileInfo[] = [];
    for (const plugin of this.plugins.values()) {
      if (plugin.getRecommendations) {
        try {
          const recs = await plugin.getRecommendations(basedOnCid);
          results = results.concat(recs);
        } catch (err) {
          console.error("PluginManager: error in getRecommendations()", err);
        }
      }
    }
    return results;
  }

  // ───────── Event Propagation to Plugins ─────────

  notifyPeerConnected(peerId: string, peer: PeerInfo): void {
    for (const plugin of this.plugins.values()) {
      if (plugin.onPeerConnected) {
        try {
          plugin.onPeerConnected(peerId, peer);
        } catch (err) {
          console.error("PluginManager: error in onPeerConnected()", err);
        }
      }
    }
  }

  notifyPeerDisconnected(peerId: string, peer: PeerInfo): void {
    for (const plugin of this.plugins.values()) {
      if (plugin.onPeerDisconnected) {
        try {
          plugin.onPeerDisconnected(peerId, peer);
        } catch (err) {
          console.error("PluginManager: error in onPeerDisconnected()", err);
        }
      }
    }
  }

  notifyFileUploaded(cid: string, fileInfo: FileInfo): void {
    for (const plugin of this.plugins.values()) {
      if (plugin.onFileUploaded) {
        try {
          plugin.onFileUploaded(cid, fileInfo);
        } catch (err) {
          console.error("PluginManager: error in onFileUploaded()", err);
        }
      }
    }
  }

  notifyFileDownloaded(cid: string): void {
    for (const plugin of this.plugins.values()) {
      if (plugin.onFileDownloaded) {
        try {
          plugin.onFileDownloaded(cid);
        } catch (err) {
          console.error("PluginManager: error in onFileDownloaded()", err);
        }
      }
    }
  }
}

filename: packages/vinyl-peer-protocol/src/Vinyl.ts
filecontent:
import { createLibp2p } from "libp2p";
import { webSockets } from "@libp2p/websockets";
import { webRTC } from "@libp2p/webrtc";
import { gossipsub } from "@chainsafe/libp2p-gossipsub";
import { circuitRelayTransport } from "@libp2p/circuit-relay-v2";
import { noise } from "@chainsafe/libp2p-noise";
import { yamux } from "@chainsafe/libp2p-yamux";
import { identify } from "@libp2p/identify";
import { kadDHT } from "@libp2p/kad-dht";
import { ping } from "@libp2p/ping";
import { bootstrap } from "@libp2p/bootstrap";
import { createHelia } from "helia";
import { unixfs } from "@helia/unixfs";

import { LevelBlockstore } from "blockstore-level";
import { Level } from "level";

import { v4 as uuidv4 } from "uuid";
import { PluginManager } from "./PluginManager.js";
import { PluginContext, VinylPeerPlugin } from "./PluginInterface.js";
import { PluginPermissions } from "./types.js";
import {
  PeerInfo,
  FileInfo,
  NetworkFileInfo,
  NodeStats,
  StorageMode,
  UploadFile,
} from "./types.js";

import crypto from "crypto";
import fs from "fs";
import path from "path";
import http from "http";

import express, { Express, Request, Response } from "express";
import multer from "multer";
import cors from "cors";
import helmet from "helmet";
import rateLimit from "express-rate-limit";
import mime from "mime-types";

import { fileURLToPath } from "url";
import { z } from "zod";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ---------- Schema for event‐envelope validation ----------
const BaseEnvelopeSchema = z.object({
  source: z.string(),
  payload: z.any(),
});

function validateEventEnvelope(envelope: any): boolean {
  try {
    BaseEnvelopeSchema.parse(envelope);
    return true;
  } catch {
    return false;
  }
}

export class Vinyl {
  // --- Core libp2p & IPFS/Helia instances ---
  private libp2p: any = null;
  private helia: any = null;
  private fs: any = null;
  private nodeStarted: boolean = false;

  // Unique node identifier
  private nodeId: string;

  // In‐memory maps of peers, streaming blobs, and network‐advertised files
  private peers: Map<string, PeerInfo> = new Map();
  private streamingFiles: Map<string, Uint8Array> = new Map();
  private networkFiles: Map<string, NetworkFileInfo> = new Map();

  // Persisted file index (metadata CIDs → FileInfo) on LevelDB
  private fileDb!: Level<string, FileInfo>;

  // Set of CIDs that have been pinned locally
  private pinnedFiles: Set<string> = new Set();

  // Allowed origins for CORS (default: allow all)
  private origin: string[] = [];

  /**
   * PLUGIN + NODE EVENT BUS:
   * An array of callbacks (eventName, { source, payload }).
   */
  private listeners: ((event: string, envelope: { source: string; payload: any }) => void)[] = [];

  // AES‐GCM CryptoKey versions map
  private cryptoKeys: Map<number, CryptoKey> = new Map();
  private currentKeyVersion: number = 0;

  // HMAC key for audit logging
  private auditKey: Buffer = crypto.randomBytes(32);
  private auditLogPath: string = path.join(__dirname, "vinyl-audit.log");

  // “Current” encryption key
  private encryptionKey: CryptoKey | null = null;

  // Whether local IPFS storage is enabled (Helia)
  private localStorageEnabled: boolean = true;

  // Plugin framework
  private pluginManager: PluginManager;
  private pluginInstances: VinylPeerPlugin[];
  private nodePermissions: PluginPermissions;

  // ─── HTTP server for core + plugins ───
  private httpApp: Express;
  private httpServer: http.Server | null = null;
  private upload: multer.Multer;
  private recentEvents: { event: string; data: any; timestamp: number }[] = [];

  constructor(plugins: VinylPeerPlugin[] = [], globalPermissions?: PluginPermissions) {
    // Generate a UUID to identify this node (if libp2p fails, fallback to this)
    this.nodeId = uuidv4();

    // Default global permissions: full trust
    this.nodePermissions = globalPermissions || {
      accessFiles: true,
      useNetwork: true,
      modifyPeers: true,
      exposeHttp: true,
    };

    this.pluginManager = new PluginManager();
    this.pluginInstances = plugins;

    // ─────────── Initialize Express & Multer ───────────
    this.httpApp = express();
    this.upload = multer({ storage: multer.memoryStorage() });
    this.setupMiddleware();
    this.setupCoreRoutes();
    this.setupEventSSE();
  }

  /**
   * Helper to detect if running in a browser (window+document exist).
   */
  private isBrowser(): boolean {
    return typeof window !== "undefined" && typeof window.document !== "undefined";
  }

  /**
   * Return a static list of libp2p bootstrap node multiaddresses.
   */
  private getBootstrapNodes(): string[] {
    return [
      "/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN",
      "/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa",
      "/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zp9qUGqUvs9TGjLiw4Xs9q3t4F4bVR",
      "/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt",
    ];
  }

  /**
   * Build transports and listen addresses based on environment:
   *  - Browser: WebRTC, WebSockets, circuit relay.
   *  - Node.js: TCP, WebSockets, circuit relay.
   */
  private async getTransportsAndAddresses(): Promise<{
    transports: any[];
    addresses: { listen: string[] };
  }> {
    if (this.isBrowser()) {
      return {
        addresses: { listen: ["/webrtc"] },
        transports: [webSockets(), webRTC(), circuitRelayTransport()],
      };
    } else {
      const { tcp } = await import("@libp2p/tcp");
      return {
        addresses: {
          listen: ["/ip4/0.0.0.0/tcp/0", "/ip4/0.0.0.0/tcp/0/ws"],
        },
        transports: [tcp(), webSockets(), circuitRelayTransport()],
      };
    }
  }

  /**
   * Build peer discovery services (bootstrap + optionally mDNS in Node).
   */
  private async getPeerDiscoveryServices(): Promise<Record<string, any>> {
    const services: Record<string, any> = {};

    // Bootstrap service
    try {
      services.bootstrap = bootstrap({ list: this.getBootstrapNodes() });
    } catch (err) {
      console.warn("Vinyl: bootstrap not available:", err);
    }

    // mDNS (Node.js only)
    if (!this.isBrowser()) {
      try {
        const { mdns } = await import("@libp2p/mdns");
        services.mdns = mdns({ interval: 1000 });
      } catch (err) {
        console.warn("Vinyl: mDNS not available:", err);
      }
    }

    return services;
  }

  private setupMiddleware(): void {
    this.httpApp.use(cors());
    this.httpApp.use(express.json());
    this.httpApp.use(express.static("public"));
  }

  /**
   * Register core HTTP routes for status, peers, files, upload/download, etc.
   */
  private setupCoreRoutes(): void {
    // ─── Node status ───
    this.httpApp.get("/api/status", (req: Request, res: Response) => {
      try {
        const stats = this.getNodeStats();
        res.json({
          status: "ok",
          nodeId: stats.id,
          isRunning: this.nodeStarted === true, // this.libp2p?.isStarted === true,
          stats,
        });
      } catch (err: any) {
        res.status(500).json({ error: err.message });
      }
    });

    this.httpApp.get("/api/plugins", (req: Request, res: Response) => {
      try {
        const allPlugins = this.pluginManager.getAllPlugins();
        const info = allPlugins.map((p: VinylPeerPlugin) => {
          const caps = p.getCapabilities();
          return {
            name: caps.name,
            version: caps.version,
            protocols: caps.protocols,
            capabilities: caps.capabilities,
          };
        });
        res.json(info);
      } catch (err: any) {
        res.status(500).json({ error: err.message });
      }
    });

    // ─── Peer list ───
    this.httpApp.get("/api/peers", (req: Request, res: Response) => {
      try {
        res.json(this.getPeers());
      } catch (err: any) {
        res.status(500).json({ error: err.message });
      }
    });

    // ─── File list ─── (reads from LevelDB)
    this.httpApp.get("/api/files", async (req: Request, res: Response) => {
      try {
        const files: FileInfo[] = [];
        // LevelDB supports async iteration
        for await (const [cid, info] of this.fileDb.iterator()) {
          files.push(info);
        }
        res.json(files);
      } catch (err: any) {
        res.status(500).json({ error: err.message });
      }
    });

    // ─── Upload ───
    this.httpApp.post(
      "/api/upload",
      this.upload.single("file"),
      async (req: Request, res: Response) => {
        try {
          if (!req.file) {
            res.status(400).json({ error: "No file uploaded" });
            return;
          }

          const storageMode = (req.body.storageMode as StorageMode) || "ipfs";
          const metadata = req.body.metadata ? JSON.parse(req.body.metadata as string) : undefined;

          const buffer = req.file.buffer;
          const originalName = req.file.originalname;
          const mimeType =
            req.file.mimetype ||
            (mime.lookup(originalName) as string) ||
            "application/octet-stream";

          // Adapt Buffer → UploadFile
          const nodeFile: UploadFile = {
            name: originalName,
            size: buffer.length,
            type: mimeType,
            arrayBuffer: async () => {
              const ab = new ArrayBuffer(buffer.byteLength);
              new Uint8Array(ab).set(buffer);
              return ab;
            },
          };

          const cid = await this.uploadFile(nodeFile, storageMode, metadata);
          res.json({ success: true, cid });
        } catch (err: any) {
          console.error("Vinyl (HTTP): upload error:", err);
          res.status(500).json({ error: err.message });
        }
      },
    );

    // ─── Download ───
    this.httpApp.get("/api/download/:cid", async (req: Request, res: Response) => {
      try {
        const cid = req.params.cid;
        const data = await this.downloadFile(cid);
        if (!data) {
          res.status(404).json({ error: "File not found" });
          return;
        }
        res.setHeader("Content-Type", "application/octet-stream");
        res.setHeader("Content-Disposition", `attachment; filename="${cid}"`);
        res.send(Buffer.from(data));
      } catch (err: any) {
        console.error("Vinyl (HTTP): download error:", err);
        res.status(500).json({ error: err.message });
      }
    });

    // ─── Search ───
    this.httpApp.get("/api/search", async (req: Request, res: Response) => {
      try {
        const query = req.query.q as string;
        if (!query) {
          res.status(400).json({ error: "Query parameter 'q' is required" });
          return;
        }
        const results = await this.searchFiles(query);
        res.json(results);
      } catch (err: any) {
        console.error("Vinyl (HTTP): search error:", err);
        res.status(500).json({ error: err.message });
      }
    });

    // ─── Pin / Unpin ───
    this.httpApp.post("/api/pin/:cid", async (req: Request, res: Response) => {
      try {
        const cid = req.params.cid;
        await this.pinFile(cid);
        res.json({ success: true, message: "File pinned successfully" });
      } catch (err: any) {
        console.error("Vinyl (HTTP): pin error:", err);
        res.status(500).json({ error: err.message });
      }
    });

    this.httpApp.delete("/api/pin/:cid", async (req: Request, res: Response) => {
      try {
        const cid = req.params.cid;
        await this.unpinFile(cid);
        res.json({ success: true, message: "File unpinned successfully" });
      } catch (err: any) {
        console.error("Vinyl (HTTP): unpin error:", err);
        res.status(500).json({ error: err.message });
      }
    });

    // ─── Health check ───
    this.httpApp.get("/health", (req: Request, res: Response) => {
      res.json({ status: "healthy", timestamp: new Date().toISOString() });
    });
  }

  /**
   * Enable Server‐Sent Events (SSE) at `/api/events` for recent events replay.
   */
  private setupEventSSE(): void {
    this.onEvent((evt, data) => {
      this.recentEvents.push({ event: evt, data, timestamp: Date.now() });
      if (this.recentEvents.length > 500) this.recentEvents.shift();
    });

    this.httpApp.get("/api/events", (req: Request, res: Response) => {
      res.writeHead(200, {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive",
      });
      res.write(":\n\n"); // initial SSE comment

      const sendEvent = (name: string, payload: any) => {
        res.write(`event: ${name}\n`);
        res.write(`data: ${JSON.stringify(payload)}\n\n`);
      };

      // Replay last 20 events
      const replayCount = Math.min(20, this.recentEvents.length);
      for (let i = this.recentEvents.length - replayCount; i < this.recentEvents.length; i++) {
        const e = this.recentEvents[i];
        sendEvent(e.event, e.data);
      }

      // Subscribe to new events
      const listener = (evtName: string, envelope: any) => {
        sendEvent(evtName, envelope.payload);
      };
      this.onEvent(listener);

      req.on("close", () => {
        // optionally remove listener, if implemented
      });
    });
  }

  /**
   * Initialize the node:
   * 1) Create/use a LevelDB for `fileDb`.
   * 2) Build libp2p with transports, DHT, Gossipsub, etc.
   * 3) Generate encryption key.
   * 4) Spin up Helia with LevelBlockstore (persisted under "./helia-repo").
   * 5) Build PluginContext and register plugins.
   * 6) Start libp2p and plugins.
   */
  async initialize(enableLocalStorage: boolean = true, origin?: string[]): Promise<boolean> {
    try {
      console.log("Vinyl: Initializing LevelDB for file metadata…");

      this.fileDb = new Level<string, FileInfo>(path.join(__dirname, "vinyl-filedb"), {
        valueEncoding: "json",
      });

      console.log("Vinyl: Initializing libp2p node…");
      this.localStorageEnabled = enableLocalStorage;
      this.origin = origin || ["*"];

      const { addresses, transports } = await this.getTransportsAndAddresses();

      const peerDiscoveryServices = await this.getPeerDiscoveryServices();

      this.libp2p = await createLibp2p({
        addresses,
        transports,
        connectionEncrypters: [noise()],
        streamMuxers: [yamux()],
        peerDiscovery: Object.values(peerDiscoveryServices),
        services: {
          identify: identify(),
          dht: kadDHT({ clientMode: this.isBrowser() }),
          ping: ping(),
          pubsub: gossipsub({ allowPublishToZeroTopicPeers: true }),
          ...peerDiscoveryServices,
        },
      });

      await this.rotateEncryptionKey();

      // If localStorage enabled, initialize Helia (IPFS) & UnixFS with LevelBlockstore
      if (this.localStorageEnabled) {
        console.log("Vinyl: Initializing Helia (IPFS) node with LevelBlockstore…");
        this.helia = await createHelia({
          libp2p: this.libp2p,
          blockstore: new LevelBlockstore(path.join(__dirname, "helia-repo")),
        });
        this.fs = unixfs(this.helia);
      } else {
        console.log("Vinyl: Local storage disabled → relay-only mode");
      }

      const pluginContext: PluginContext = {
        nodeId: this.libp2p.peerId.toString(),
        libp2p: this.libp2p,
        files: this.filesView(),
        peers: this.peers,
        networkFiles: this.networkFiles,
        emit: (event, envelope) => {
          if (!validateEventEnvelope(envelope)) {
            console.warn("Vinyl: invalid event envelope, dropping:", envelope);
            return;
          }
          for (const listener of this.listeners) {
            try {
              listener(event, envelope);
            } catch {
              // ignore
            }
          }
        },
        pinFile: this.pinFile.bind(this),
        unpinFile: this.unpinFile.bind(this),
        getPermissions: () => this.nodePermissions,
        helia: this.helia!,
        fileDb: this.fileDb!,
        pluginManager: this.pluginManager,
        httpApp: this.httpApp,
        onEvent: this.onEvent.bind(this),
      };
      this.pluginManager.setContext(pluginContext);

      for (const plugin of this.pluginInstances) {
        const caps = plugin.getCapabilities();
        console.log(`Vinyl: registering plugin "${caps.name}" v${caps.version}…`);
        const success = await this.pluginManager.registerPlugin(plugin);
        if (success) {
          await this.signAndAppend({
            timestamp: new Date().toISOString(),
            event: "pluginRegister",
            plugin: caps.name,
            details: { version: caps.version, protocols: caps.protocols },
          });
        } else {
          console.warn(`Vinyl: plugin "${caps.name}" failed to register`);
        }
      }

      this.setupEventListeners();
      await this.libp2p.start();
      this.nodeStarted = true;

      await this.pluginManager.startAllPlugins();

      console.log(`Vinyl: Node started with ID: ${this.libp2p.peerId.toString()}`);
      console.log(`Vinyl: Local storage: ${this.localStorageEnabled ? "Enabled" : "Disabled"}`);
      console.log(`Vinyl: Registered plugins: ${this.pluginInstances.length}`);
      this.emit("nodeStarted", {
        source: "vinyl",
        payload: { nodeId: this.libp2p.peerId.toString() },
      });

      setInterval(
        () => {
          this.rotateEncryptionKey().catch((err) => {
            console.error("Vinyl: key rotation failed:", err);
          });
        },

        24 * 60 * 60 * 1000,
      );

      return true;
    } catch (error: any) {
      console.error("Vinyl: Failed to initialize node:", error);
      this.emit("error", { source: "vinyl", payload: { error: error.message } });
      return false;
    }
  }

  /**
   * Convert our LevelDB `fileDb` into an object that mimics a Map interface
   * (so plugins that do `context.files.values()` still work). We return an
   * async‐iterator of all values in LevelDB.
   */
  private filesView(): Map<string, FileInfo> {
    const pseudoMap = new Map<string, FileInfo>();
    (async () => {
      for await (const [cid, info] of this.fileDb.iterator()) {
        pseudoMap.set(cid, info);
      }
    })();
    return pseudoMap;
  }

  /**
   * Mount each plugin’s HTTP router onto our Express app under its namespace.
   * Must be called after initialize() so plugins have been registered.
   */
  private mountPluginRouters(): void {
    const allPlugins = this.pluginManager.getAllPlugins();
    for (const plugin of allPlugins) {
      if (
        typeof (plugin as any).getHttpNamespace === "function" &&
        typeof (plugin as any).getHttpRouter === "function"
      ) {
        let namespace: string = (plugin as any).getHttpNamespace();
        const router = (plugin as any).getHttpRouter();

        // Normalize namespace: must start with "/" and have no trailing slash
        if (!namespace.startsWith("/")) {
          namespace = "/" + namespace;
        }
        if (namespace.endsWith("/") && namespace.length > 1) {
          namespace = namespace.slice(0, -1);
        }

        const limiter = rateLimit({
          windowMs: 15 * 60 * 1000,
          max: 100,
          standardHeaders: true,
          legacyHeaders: false,
          message: { error: "Too many requests – try again later." },
        });

        this.httpApp.use(
          namespace,
          cors({
            origin: this.origin,
            methods: ["GET", "POST", "PUT", "DELETE"],
            credentials: true,
          }),
          helmet(),
          limiter as any,
          router as any,
        );
        console.log(`Vinyl (HTTP): mounted plugin routes at "${namespace}"`);
      }
    }
  }

  /**
   * Start the Express HTTP server (mount core + plugin routes).
   */
  startHttp(port: number = 3001): Promise<void> {
    return new Promise(async (resolve, reject) => {
      try {
        this.mountPluginRouters();
        this.httpServer = this.httpApp.listen(port, () => {
          console.log(`Vinyl (HTTP): listening on http://localhost:${port}`);
          resolve();
        });
      } catch (err) {
        reject(err);
      }
    });
  }

  /**
   * Stop the Express HTTP server gracefully.
   */
  stopHttp(): Promise<void> {
    return new Promise((resolve) => {
      if (this.httpServer) {
        this.httpServer.close(() => {
          console.log("Vinyl (HTTP): stopped");
          resolve();
        });
      } else {
        resolve();
      }
    });
  }

  /**
   * Rotate AES‐GCM key: generate a new CryptoKey, increment version, prune old keys, log event.
   */
  private async rotateEncryptionKey(): Promise<void> {
    this.currentKeyVersion++;
    let newKey: CryptoKey;

    if (this.isBrowser() && window.crypto && window.crypto.subtle) {
      newKey = await window.crypto.subtle.generateKey({ name: "AES-GCM", length: 256 }, true, [
        "encrypt",
        "decrypt",
      ]);
    } else if (crypto.webcrypto && crypto.webcrypto.subtle) {
      newKey = await crypto.webcrypto.subtle.generateKey({ name: "AES-GCM", length: 256 }, true, [
        "encrypt",
        "decrypt",
      ]);
    } else {
      throw new Error("Web Crypto AES‐GCM not available");
    }

    this.cryptoKeys.set(this.currentKeyVersion, newKey);

    // Keep only the last 3 key versions // TO-DO recovery after key rotation, since we can’t decrypt old files
    if (this.cryptoKeys.size > 3) {
      const oldest = Math.min(...Array.from(this.cryptoKeys.keys()));
      this.cryptoKeys.delete(oldest);
    }

    await this.signAndAppend({
      timestamp: new Date().toISOString(),
      event: "keyRotation",
      plugin: "core",
      details: { version: this.currentKeyVersion },
    });

    this.encryptionKey = newKey;
  }

  /**
   * Append a signed audit entry to disk. Each entry = JSON line with HMAC‐SHA256 signature.
   */
  private async signAndAppend(entry: {
    timestamp: string;
    event: string;
    plugin: string;
    details: Record<string, any>;
  }): Promise<void> {
    const payload = JSON.stringify(entry);
    const hmac = crypto.createHmac("sha256", this.auditKey);
    hmac.update(payload);
    const signature = hmac.digest("hex");
    const line = JSON.stringify({ ...entry, signature }) + "\n";
    fs.appendFileSync(this.auditLogPath, line);
  }

  /**
   * Search across:
   * 1) Local files (metadata in LevelDB) by matching name only
   * 2) Known networkFiles by matching name only
   * 3) Delegate to each plugin.searchFiles(...)
   */
  async searchFiles(query: string): Promise<NetworkFileInfo[]> {
    const results: NetworkFileInfo[] = [];
    const searchTerm = query.toLowerCase();

    for await (const [_, fileInfo] of this.fileDb.iterator()) {
      if (fileInfo.name.toLowerCase().includes(searchTerm)) {
        results.push({
          ...fileInfo,
          peerId: this.libp2p.peerId.toString(),
          peerAddress: "local",
          availability: "online",
        });
      }
    }

    for (const file of this.networkFiles.values()) {
      if (file.name.toLowerCase().includes(searchTerm)) {
        results.push(file);
      }
    }

    const pluginResults = await this.pluginManager.searchFiles(query);
    results.push(...pluginResults);

    return results;
  }

  /**
   * Delegate to plugins for recommendations based on a given base CID.
   */
  async getRecommendations(basedOnCid: string): Promise<NetworkFileInfo[]> {
    return await this.pluginManager.getRecommendations(basedOnCid);
  }

  /**
   * Upload a file:
   * 1) Read raw bytes (ArrayBuffer)
   * 2) Encrypt with AES‐GCM (prepend version + IV)
   * 3) If storageMode = "ipfs" and localStorageEnabled, add encrypted bytes to Helia→CID
   *    Else create a “stream‐<uuid>” and keep in memory
   * 4) Let plugins enhance metadata
   * 5) Build metadata object and store it (either Helia or in‐memory)
   * 6) Persist metadata FileInfo in LevelDB
   * 7) Notify plugins and emit “fileUploaded”
   */
  async uploadFile(
    file: UploadFile,
    storageMode: StorageMode = "ipfs",
    metadata?: any,
  ): Promise<string> {
    try {
      console.log(
        `Vinyl: uploading file "${file.name}" via ${storageMode} with metadata:`,
        metadata,
      );

      if (!this.localStorageEnabled && storageMode === "ipfs") {
        throw new Error("Local IPFS storage is disabled. Use P2P streaming instead.");
      }
      if (!this.encryptionKey) {
        throw new Error("Encryption key is not initialized");
      }

      const arrayBuffer = await file.arrayBuffer();

      const iv = this.isBrowser()
        ? window.crypto.getRandomValues(new Uint8Array(12))
        : crypto.webcrypto.getRandomValues(new Uint8Array(12));

      const encryptedBuffer = this.isBrowser()
        ? await window.crypto.subtle.encrypt(
            { name: "AES-GCM", iv },
            this.encryptionKey!,
            arrayBuffer,
          )
        : await crypto.webcrypto.subtle.encrypt(
            { name: "AES-GCM", iv },
            this.encryptionKey!,
            arrayBuffer,
          );
      const ciphertext = new Uint8Array(encryptedBuffer);

      const versionByte = new Uint8Array([this.currentKeyVersion]);
      const combined = new Uint8Array(1 + iv.byteLength + ciphertext.byteLength);
      combined.set(versionByte, 0);
      combined.set(iv, 1);
      combined.set(ciphertext, 1 + iv.byteLength);

      let storedCID: string;
      let storedStreamId: string | undefined;

      if (storageMode === "ipfs" && this.localStorageEnabled) {
        const ipfsCID = await this.fs.addBytes(combined);
        storedCID = ipfsCID.toString();
      } else {
        storedStreamId = uuidv4();
        storedCID = `stream-${storedStreamId}`;
        this.streamingFiles.set(storedStreamId, combined);
        this.announceStream(storedStreamId, file.name, file.size);
      }

      let finalMetadata: any = {};
      const pluginMetadata = await this.pluginManager.enhanceFileMetadata(file);
      finalMetadata = { ...pluginMetadata };

      if (metadata) {
        finalMetadata = { ...finalMetadata, ...metadata };
      }

      const metadataObject = {
        name: file.name,
        size: file.size,
        type: file.type,
        uploadDate: new Date().toISOString(),
        storageMode,
        storedCID,
        metadata: finalMetadata,
      };

      let metadataCID: string;
      let metadataStreamId: string | undefined;
      if (storageMode === "ipfs" && this.localStorageEnabled) {
        const metadataBytes = new TextEncoder().encode(JSON.stringify(metadataObject));
        const ipfsMetadataCID = await this.fs.addBytes(metadataBytes);
        metadataCID = ipfsMetadataCID.toString();
      } else {
        metadataStreamId = uuidv4();
        metadataCID = `metadata-${metadataStreamId}`;
        const metadataBytes = new TextEncoder().encode(JSON.stringify(metadataObject));
        this.streamingFiles.set(metadataStreamId, metadataBytes);
      }

      const fileInfo: FileInfo = {
        cid: metadataCID,
        name: file.name,
        size: file.size,
        type: file.type,
        uploadDate: new Date(),
        encrypted: true,
        storageMode,
        streamId: metadataStreamId,
        pinned: false,
        shareLink: this.generateShareLink(metadataCID, storageMode),
        metadata: finalMetadata,
      };

      await this.fileDb.put(metadataCID, fileInfo);

      this.pluginManager.notifyFileUploaded(metadataCID, fileInfo);
      this.emit("fileUploaded", {
        source: "vinyl",
        payload: { cid: metadataCID, fileInfo },
      });
      return metadataCID;
    } catch (error: any) {
      console.error("Vinyl: Failed to upload file:", error);
      this.emit("error", { source: "vinyl", payload: { error: error.message } });
      throw error;
    }
  }

  /**
   * Generate a shareable URI for the file:
   *  - IPFS: "vinyl://ipfs/<cid>"
   *  - P2P streaming: "vinyl://stream/<cid>"
   */
  private generateShareLink(cid: string, storageMode: StorageMode): string {
    return storageMode === "ipfs" ? `vinyl://ipfs/${cid}` : `vinyl://stream/${cid}`;
  }

  /**
   * Download a file by CID:
   * 1) If this is a metadataCID (exists in fileDb), return raw metadata JSON bytes.
   * 2) Otherwise (encrypted payload), fetch+decrypt and return decrypted bytes.
   * On success, notify plugins via notifyFileDownloaded and emit "fileDownloaded".
   */
  async downloadFile(cid: string): Promise<Uint8Array | null> {
    try {
      console.log(`Vinyl: downloading file with CID "${cid}"`);

      if (!this.encryptionKey) {
        throw new Error("Encryption key is not initialized");
      }

      let fileInfo: FileInfo | null = null;
      try {
        fileInfo = await this.fileDb.get(cid);
      } catch {
        // not in LevelDB
      }
      if (fileInfo) {
        // It’s a metadata JSON blob
        if (fileInfo.storageMode === "ipfs") {
          const catStream = this.fs.cat(cid);
          const chunks: Uint8Array[] = [];
          for await (const chunk of catStream) {
            chunks.push(chunk);
          }
          const all = chunks.flatMap((c) => Array.from(c));
          return new Uint8Array(all);
        } else {
          const metadataStreamId = fileInfo.streamId!;
          const metadataBytes = this.streamingFiles.get(metadataStreamId);
          if (!metadataBytes) {
            console.warn(`Vinyl: no streaming metadata for ID "${metadataStreamId}"`);
            return null;
          }
          return metadataBytes;
        }
      }

      let encryptedData: Uint8Array | undefined;
      if (cid.startsWith("stream-")) {
        const streamId = cid.replace(/^stream-/, "");
        encryptedData = this.streamingFiles.get(streamId);
        if (!encryptedData) {
          console.warn(`Vinyl: streaming audio "${streamId}" not found locally`);
          throw new Error("Stream not available");
        }
      } else {
        // IPFS retrieval via Helia
        if (!this.localStorageEnabled || !this.fs) {
          throw new Error("Local IPFS storage is disabled");
        }
        const catStream = this.fs.cat(cid);
        const chunks: Uint8Array[] = [];
        for await (const chunk of catStream) {
          chunks.push(chunk);
        }
        const all = chunks.flatMap((c) => Array.from(c));
        encryptedData = new Uint8Array(all);
      }

      const decrypted = await this.decryptFileData(encryptedData!);
      this.pluginManager.notifyFileDownloaded(cid);
      return decrypted;
    } catch (error: any) {
      console.error("Vinyl: Failed to download file:", error);
      this.emit("error", { source: "vinyl", payload: { error: error.message } });
      return null;
    }
  }

  /**
   * Decrypt a Uint8Array that was encrypted via AES‐GCM:
   * format = [version(1) | IV(12) | ciphertext…].
   */
  private async decryptFileData(encryptedData: Uint8Array): Promise<Uint8Array> {
    const version = encryptedData[0];
    const key = this.cryptoKeys.get(version);
    if (!key) {
      throw new Error(`Missing decryption key for version ${version}`);
    }
    const iv = encryptedData.slice(1, 13);
    const ciphertext = encryptedData.slice(13);

    const decryptedBuffer = this.isBrowser()
      ? await window.crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, ciphertext)
      : await crypto.webcrypto.subtle.decrypt({ name: "AES-GCM", iv }, key, ciphertext);

    return new Uint8Array(decryptedBuffer);
  }

  /**
   * Announce a new P2P streaming file.
   */
  private announceStream(streamId: string, fileName: string, fileSize: number): void {
    console.log(
      `Vinyl: announcing stream "${fileName}" (size: ${fileSize}) → streamId="${streamId}"`,
    );
  }

  /**
   * Pin a file in Helia/IPFS; update FileInfo & emit "filePinned".
   * If localStorage is disabled, throws an error.
   */
  async pinFile(cid: string): Promise<void> {
    try {
      if (!this.localStorageEnabled || !this.helia) {
        throw new Error("Local storage is disabled; cannot pin files.");
      }
      await this.helia.pins.add(cid);
      this.pinnedFiles.add(cid);

      // Update FileInfo.pinned = true in LevelDB
      let fi: FileInfo | null = null;
      try {
        fi = await this.fileDb.get(cid);
      } catch {
        // not in DB
      }
      if (fi) {
        fi.pinned = true;
        await this.fileDb.put(cid, fi);
      }

      this.emit("filePinned", { source: "vinyl", payload: { cid } });
      console.log(`Vinyl: pinned file "${cid}"`);

      // Audit log
      await this.signAndAppend({
        timestamp: new Date().toISOString(),
        event: "filePin",
        plugin: "core",
        details: { cid },
      });
    } catch (error: any) {
      console.error("Vinyl: pinFile failed:", error);
      this.emit("error", { source: "vinyl", payload: { error: error.message } });
      throw error;
    }
  }

  /**
   * Unpin a file in Helia/IPFS; update FileInfo & emit "fileUnpinned".
   * If localStorage is disabled, throws an error.
   */
  async unpinFile(cid: string): Promise<void> {
    try {
      if (!this.localStorageEnabled || !this.helia) {
        throw new Error("Local storage is disabled; cannot unpin files.");
      }
      await this.helia.pins.rm(cid);
      this.pinnedFiles.delete(cid);

      // Update FileInfo.pinned = false in LevelDB
      let fi: FileInfo | null = null;
      try {
        fi = await this.fileDb.get(cid);
      } catch {
        // not in DB
      }
      if (fi) {
        fi.pinned = false;
        await this.fileDb.put(cid, fi);
      }

      this.emit("fileUnpinned", { source: "vinyl", payload: { cid } });
      console.log(`Vinyl: unpinned file "${cid}"`);

      // Audit log
      await this.signAndAppend({
        timestamp: new Date().toISOString(),
        event: "fileUnpin",
        plugin: "core",
        details: { cid },
      });
    } catch (error: any) {
      console.error("Vinyl: unpinFile failed:", error);
      this.emit("error", { source: "vinyl", payload: { error: error.message } });
      throw error;
    }
  }

  /**
   * Set up libp2p event listeners for peer connect/disconnect,
   * then notify plugins and emit our own events.
   */
  private setupEventListeners(): void {
    if (!this.libp2p) return;

    this.libp2p.addEventListener("peer:connect", (evt: any) => {
      const peerId = evt.detail.toString();
      const peerInfo: PeerInfo = {
        id: peerId,
        address: "unknown",
        status: "connected",
        lastSeen: new Date(),
      };
      this.peers.set(peerId, peerInfo);
      this.pluginManager.notifyPeerConnected(peerId, peerInfo);
      this.emit("peerConnected", { source: "vinyl", payload: { peerId } });
    });

    this.libp2p.addEventListener("peer:disconnect", (evt: any) => {
      const peerId = evt.detail.toString();
      const pi = this.peers.get(peerId);
      if (pi) {
        pi.status = "disconnected";
        this.peers.set(peerId, pi);
        this.pluginManager.notifyPeerDisconnected(peerId, pi);
      }
      this.emit("peerDisconnected", { source: "vinyl", payload: { peerId } });
    });
  }

  /**
   * Return aggregated node statistics for monitoring:
   *  - id, isOnline, peer counts, file counts, etc.
   */
  getNodeStats(): NodeStats {
    const connectedPeers = Array.from(this.peers.values()).filter((p) => p.status === "connected");
    return {
      id: this.libp2p?.peerId?.toString() || this.nodeId,
      isOnline: this.libp2p?.isStarted === true,
      connectedPeers: connectedPeers.length,
      totalPeers: this.peers.size,
      uploadedFiles: 0, // could increment on upload
      downloadedFiles: 0, // track if needed
      storageUsed: this.localStorageEnabled ? 0 : -1,
      storageAvailable: this.localStorageEnabled ? 1000 * 1024 * 1024 : 0,
      pinnedFiles: this.pinnedFiles.size,
    };
  }

  /** Return a snapshot list of known peers. */
  getPeers(): PeerInfo[] {
    return Array.from(this.peers.values());
  }

  /** Return a snapshot list of local FileInfo (reads from fileDb). */
  async getFiles(): Promise<FileInfo[]> {
    const files: FileInfo[] = [];
    for await (const [, info] of this.fileDb.iterator()) {
      files.push(info);
    }
    return files;
  }

  /** Return a snapshot list of NetworkFileInfo for known network‐advertised files. */
  getNetworkFiles(): NetworkFileInfo[] {
    return Array.from(this.networkFiles.values());
  }

  /**
   * Subscribe to node‐level events.
   */
  public on(callback: (event: string, envelope: { source: string; payload: any }) => void): void {
    this.listeners.push(callback);
  }

  /** Alias for `on(...)`. */
  public onEvent(
    callback: (event: string, envelope: { source: string; payload: any }) => void,
  ): void {
    this.on(callback);
  }

  /**
   * PUBLIC EMIT: call all listeners with (eventName, envelope).
   */
  public emit(event: string, envelope: { source?: string; payload: any }): void {
    if (!envelope.source) {
      envelope.source = "vinyl";
    }
    if (!validateEventEnvelope(envelope)) {
      console.warn("Vinyl: emit called with invalid envelope, dropping:", envelope);
      return;
    }
    for (const listener of this.listeners) {
      try {
        listener(event, envelope as { source: string; payload: any });
      } catch {
        // ignore listener errors
      }
    }
  }

  /**
   * Return the PluginManager so external code can query installed plugins.
   */
  getPluginManager(): PluginManager {
    return this.pluginManager;
  }

  /**
   * Gracefully shut down all plugins → Helia → libp2p.
   */
  async stop(): Promise<void> {
    await this.pluginManager.stopAllPlugins();
    if (this.helia) {
      await this.helia.stop();
    }
    if (this.libp2p) {
      await this.libp2p.stop();
    }
    console.log("Vinyl: Node stopped");

    await this.signAndAppend({
      timestamp: new Date().toISOString(),
      event: "nodeStopped",
      plugin: "core",
      details: { nodeId: this.libp2p?.peerId?.toString() || this.nodeId },
    });
  }
}

filename: packages/vinyl-peer-protocol/src/types.ts
filecontent:
import type { Application, Router } from "express";
import { Level } from "level";
import { Helia } from "helia";
import type { PluginManager } from "./PluginManager.js";
import type { Express } from "express";

/**
 * PeerInfo: Basic information about a peer in the network.
 */
export interface PeerInfo {
  id: string;
  address: string;
  status: "connected" | "disconnected" | "connecting";
  lastSeen: Date;
  latency?: number;
}

/**
 * NodeStats: Aggregated statistics about the local node.
 */
export interface NodeStats {
  id: string;
  isOnline: boolean;
  connectedPeers: number;
  totalPeers: number;
  uploadedFiles: number;
  downloadedFiles: number;
  storageUsed: number;
  storageAvailable: number;
  pinnedFiles: number;
}

/**
 * StorageMode: Whether to store data in IPFS or via P2P streaming.
 */
export type StorageMode = "ipfs" | "p2p-stream";

/**
 * FileInfo: Metadata for a stored file.
 */
export interface FileInfo {
  cid: string;
  name: string;
  size: number;
  type: string;
  uploadDate: Date;
  encrypted: boolean;
  storageMode: StorageMode;
  streamId?: string;
  pinned?: boolean;
  shareLink?: string;
  metadata?: any;
}

/**
 * NetworkFileInfo: A FileInfo plus which peer it's hosted on and availability.
 */
export interface NetworkFileInfo extends FileInfo {
  peerId: string;
  peerAddress: string;
  availability: "online" | "offline";
}

/**
 * UploadFile: An abstraction for any “file‐like” object that can produce an ArrayBuffer.
 * (For example, a browser File or our NodeFile wrapper).
 */
export interface UploadFile {
  name: string;
  size: number;
  type: string;
  arrayBuffer(): Promise<ArrayBuffer>;
}

/**
 * PluginPermissions: Defines what a plugin is allowed to do.
 */
export interface PluginPermissions {
  accessFiles: boolean;
  useNetwork: boolean;
  modifyPeers: boolean;
  exposeHttp?: boolean;
}

/**
 * PluginContext: Provided by Vinyl → plugins upon initialization.
 */
export interface PluginContext {
  nodeId: string;
  libp2p: any;
  files: Map<string, FileInfo>;
  peers: Map<string, PeerInfo>;
  networkFiles: Map<string, NetworkFileInfo>;

  /**
   * Internal event emitter. Every call will include an envelope:
   *   { source: <pluginName>, payload: <whatever> }.
   * Validated against a schema before dispatch.
   */
  emit: (event: string, envelope: { source: string; payload: any }) => void;

  /** Pin a CID on this node (download/store it locally). */
  pinFile: (cid: string) => Promise<void>;
  /** Unpin a CID on this node. */
  unpinFile: (cid: string) => Promise<void>;

  /** Retrieve this plugin’s permissions. */
  getPermissions: () => PluginPermissions;
  fileDb: Level<string, FileInfo>;
  helia: Helia;
  pluginManager: PluginManager;
  httpApp?: Express;
  onEvent: (callback: (event: string, envelope: { source: string; payload: any }) => void) => void;
}

/**
 * PluginCapabilities: Declares what a plugin supports.
 */
export interface PluginCapabilities {
  name: string;
  version: string;
  /** e.g. ["/music-discovery/1.0.0", ...] */
  protocols: string[];
  /** e.g. ["streaming","discovery","recommendations"] */
  capabilities: string[];
  fileTypes?: string[];
  permissions: PluginPermissions;
}

/**
 * HttpPlugin: If a plugin wishes to expose HTTP routes,
 * it must implement getHttpNamespace() + getHttpRouter().
 */
export interface HttpPlugin {
  /** e.g. returns "/analytics" */
  getHttpNamespace(): string;
  /** Return an Express.Application or an Express.Router. */
  getHttpRouter(): Application | Router;
}

/**
 * VinylPeerPlugin: Core plugin interface.
 */
export interface VinylPeerPlugin {
  getCapabilities(): PluginCapabilities;
  initialize(context: PluginContext): Promise<boolean>;
  start(): Promise<void>;
  stop(): Promise<void>;
  setupProtocols(): void;
  handleProtocol(protocol: string, stream: any, peerId: string): Promise<void>;

  canHandleFile?(file: FileInfo): boolean;
  processFile?(file: FileInfo, context: PluginContext): Promise<any>;
  enhanceMetadata?(file: UploadFile): Promise<any>;

  searchFiles?(query: any): Promise<NetworkFileInfo[]>;
  getRecommendations?(basedOnCid: string): Promise<NetworkFileInfo[]>;

  identifyPeer?(peerId: string): Promise<boolean>;

  onPeerConnected?(peerId: string, peer: PeerInfo): void;
  onPeerDisconnected?(peerId: string, peer: PeerInfo): void;
  onFileUploaded?(cid: string, fileInfo: FileInfo): void;
  onFileDownloaded?(cid: string): void;

  getHttpNamespace?(): string;
  getHttpRouter?(): Application | Router;
}

filename: packages/vinyl-peer-protocol/src/index.ts
filecontent:
export * from "./types.js";
export * from "./PluginInterface.js";
export * from "./PluginManager.js";
export * from "./Vinyl.js";

filename: packages/vinyl-peer-protocol/src/PluginInterface.ts
filecontent:
import {
  PeerInfo,
  FileInfo,
  NetworkFileInfo,
  UploadFile,
  PluginContext,
  PluginCapabilities,
  PluginPermissions,
  VinylPeerPlugin,
} from "./types.js";

/**
 * We’ve removed the duplicate interface/type declarations here, since those
 * are already exported by `types.js`. Instead, we re‐export them and then
 * provide `BasePlugin`’s implementation below.
 */

/**
 * Re-export types that were originally defined in types.js
 */
export type {
  PeerInfo,
  FileInfo,
  NetworkFileInfo,
  UploadFile,
  PluginContext,
  PluginCapabilities,
  PluginPermissions,
  VinylPeerPlugin,
};

/**
 * BasePlugin: Abstract class that enforces initialize → start ordering
 * and wraps `emit()` so that every event is tagged with `source: pluginName`.
 *
 * (Originally this lived here, but its type signatures are already in types.js.
 *  We simply provide the implementation now, without redeclaring interfaces.)
 */
export abstract class BasePlugin implements VinylPeerPlugin {
  protected context: PluginContext | null = null;
  protected isInitialized: boolean = false;
  protected isStarted: boolean = false;

  /** Must be implemented by each plugin to declare its name/version/protocols, etc. */
  abstract getCapabilities(): PluginCapabilities;

  async initialize(context: PluginContext): Promise<boolean> {
    this.context = context;
    this.isInitialized = true;

    // Verify plugin requested permissions do not exceed context‐granted permissions
    const requested = this.getCapabilities().permissions;
    const granted = context.getPermissions();
    for (const perm of Object.keys(requested) as (keyof PluginPermissions)[]) {
      if (requested[perm] && !granted[perm]) {
        console.error(
          `Plugin "${this.getCapabilities().name}" requested unauthorized permission: ${perm}`,
        );
        return false;
      }
    }
    return true;
  }

  async start(): Promise<void> {
    if (!this.isInitialized) {
      throw new Error("Plugin must be initialized before starting");
    }
    this.setupProtocols();
    this.isStarted = true;
  }

  async stop(): Promise<void> {
    this.isStarted = false;
  }

  abstract setupProtocols(): void;
  abstract handleProtocol(protocol: string, stream: any, peerId: string): Promise<void>;

  /**
   * Wrap every emitted event in an envelope: { source: pluginName, payload }.
   * Performs a basic check before dispatch.
   */
  protected emit(event: string, payload: any): void {
    if (!this.context) return;
    const pluginName = this.getCapabilities().name;
    if (typeof event !== "string" || event.trim() === "") {
      console.warn(`Plugin "${pluginName}" attempted to emit invalid event:`, event);
      return;
    }
    this.context.emit(event, { source: pluginName, payload });
  }
}

filename: packages/vinyl-peer-cli/tsconfig.esm.json
filecontent:
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "module": "ESNext",                // produce ESM
    "target": "ES2020",                // or whatever target you prefer
    "outDir": "dist/esm",              // everything goes under dist/esm
    "declaration": true,               // emit .d.ts files
    "declarationDir": "dist/esm",      // put .d.ts next to .js
    "strict": true,
    "esModuleInterop": true,
    "moduleResolution": "node",
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}

filename: packages/vinyl-peer-cli/package.json
filecontent:
{
  "name": "vinyl-peer-cli",
  "version": "0.0.1",
  "authors": [
    "KDLabs"
  ],
  "type": "module",
  "main": "dist/cjs/index.js",
  "module": "dist/esm/index.js",
  "types": "dist/esm/index.d.ts",
  "exports": {
    "import": "./dist/esm/index.js",
    "require": "./dist/cjs/index.js"
  },
  "scripts": {
    "build:esm": "tsc -p tsconfig.esm.json",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build": "rimraf dist && npm run build:esm && npm run build:cjs",
    "test": "vitest"
  },
  "dependencies": {
    "commander": "^9.4.0",
    "cors": "^2.8.5",
    "express": "^5.1.0",
    "express-rate-limit": "^7.5.0",
    "helmet": "^8.1.0",
    "mime-types": "^2.1.34",
    "multer": "^1.4.5-lts.1",
    "react": "^19.1.0",
    "tsx": "^4.19.4",
    "vinyl-peer-plugin-analytics": "workspace:*",
    "vinyl-peer-plugin-music": "workspace:*",
    "vinyl-peer-protocol": "workspace:*"
  },
  "devDependencies": {
    "@types/commander": "^2.12.2",
    "@types/cors": "^2.8.12",
    "@types/express": "^5.0.2",
    "@types/express-serve-static-core": "5.0.6",
    "@types/mime-types": "^2.1.0",
    "@types/multer": "^1.4.7",
    "@types/node": "^22.5.5",
    "typescript": "^5.7.3",
    "vitest": "^3.0.5"
  }
}

filename: packages/vinyl-peer-cli/tsconfig.cjs.json
filecontent:
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "module": "CommonJS",     // produce CJS
    "target": "ES2020",       
    "outDir": "dist/cjs",     // everything goes under dist/cjs
    "declaration": false      // we don’t need .d.ts here (we already emitted them under dist/esm)
  },
  "include": ["src/**/*"]
}

filename: packages/vinyl-peer-cli/src/Node.ts
filecontent:
import { UploadFile } from "vinyl-peer-protocol";

/**
 * NodeFile: Adapts a Node.js Buffer into our UploadFile interface,
 * so that Vinyl.uploadFile(...) can accept it just like a browser File.
 */
export class NodeFile implements UploadFile {
  name: string;
  size: number;
  type: string;
  private buffer: Buffer;

  constructor(buffer: Buffer, name: string, type: string = "application/octet-stream") {
    this.buffer = buffer;
    this.name = name;
    this.type = type;
    this.size = buffer.length;
  }

  async arrayBuffer(): Promise<ArrayBuffer> {
    // Copy the Buffer’s contents into a new ArrayBuffer:
    const ab = new ArrayBuffer(this.buffer.byteLength);
    const view = new Uint8Array(ab);
    view.set(this.buffer);
    return ab;
  }
}

filename: packages/vinyl-peer-cli/src/index.ts
filecontent:
import { Command } from "commander";
import path from "path";
import fs from "fs";
import { Vinyl, VinylPeerPlugin } from "vinyl-peer-protocol";
import { MusicPlugin } from "vinyl-peer-plugin-music";
import { AnalyticsPlugin } from "vinyl-peer-plugin-analytics";
import mime from "mime-types";
import { NodeManager } from "./NodeManager.js";
import { NodeFile } from "./Node.js";

const program = new Command();

class CLIManager {
  public vinyl!: Vinyl;
  private nodeManager: NodeManager | null = null;

  constructor() {}

  async start(plugins: VinylPeerPlugin[], enableLocalStorage: boolean): Promise<boolean> {
    this.vinyl = new Vinyl();

    const success = await this.vinyl.initialize(enableLocalStorage);
    if (!success) {
      return false;
    }

    const pluginManager = this.vinyl.getPluginManager();
    for (const plugin of plugins) {
      await pluginManager.registerPlugin(plugin);
    }
    await pluginManager.startAllPlugins();

    this.nodeManager = new NodeManager(this.vinyl as any);
    return true;
  }

  async uploadFile(
    nodeFile: NodeFile,
    storageMode: "ipfs" | "p2p-stream",
    metadata?: any,
  ): Promise<string> {
    return await this.vinyl.uploadFile(nodeFile, storageMode, metadata);
  }

  async downloadFile(cid: string): Promise<Uint8Array | null> {
    return await this.vinyl.downloadFile(cid);
  }

  getStats() {
    return this.vinyl.getNodeStats();
  }

  getPeers() {
    return this.vinyl.getPeers();
  }

  getFiles() {
    return this.vinyl.getFiles();
  }

  async searchFiles(query: string) {
    return await this.vinyl.searchFiles(query);
  }

  async getRecommendations(cid: string) {
    return await this.vinyl.getRecommendations(cid);
  }

  getNodeId(): string {
    if (!this.nodeManager) {
      throw new Error("NodeManager not initialized");
    }
    return this.nodeManager.getNodeId();
  }

  isNodeRunning(): boolean {
    if (!this.nodeManager) {
      throw new Error("NodeManager not initialized");
    }
    return this.nodeManager.isNodeRunning();
  }

  async pinFile(cid: string): Promise<void> {
    return await this.vinyl.pinFile(cid);
  }

  async unpinFile(cid: string): Promise<void> {
    return await this.vinyl.unpinFile(cid);
  }

  onEvent(callback: (event: string, data: any) => void) {
    // delegate to Vinyl’s event bus
    this.vinyl.onEvent(callback);
  }

  async stop() {
    await this.vinyl.stop();
  }
}

program.name("vinyl-peer").description("Vinyl Peer – P2P Music Sharing Network").version("1.0.0");

function instantiatePlugins(list: string): VinylPeerPlugin[] {
  const names = list.split(",").map((s) => s.trim().toLowerCase());
  const result: VinylPeerPlugin[] = [];

  for (const name of names) {
    if (name === "music") {
      result.push(new MusicPlugin());
    } else if (name === "analytics") {
      result.push(new AnalyticsPlugin());
    } else if (name === "") {
      // skip empty entries
    } else {
      console.warn(`Warning: unrecognized plugin "${name}" – ignoring.`);
    }
  }

  return result;
}

/**
 * `start` command:
 *   - --no-local-storage: run as relay-only (no IPFS)
 *   - -p, --plugins <list>: comma-separated plugin names (e.g. "music,analytics")
 *     Default: "music,analytics"
 */
program
  .command("start")
  .description("Start the Vinyl Peer node")
  .option("--no-local-storage", "Disable local IPFS storage (relay-only mode)")
  .option(
    "-p, --plugins <list>",
    "Comma-separated list of plugins to load (music,analytics)",
    "music,analytics",
  )
  .action(async (options) => {
    console.log("🎵 Starting Vinyl Peer node...");
    const cliManager = new CLIManager();

    const pluginList = instantiatePlugins(options.plugins as string);

    try {
      const success = await cliManager.start(pluginList, options.localStorage !== false);
      if (!success) {
        console.error("❌ Failed to start node");
        process.exit(1);
      }

      console.log("✅ Node started successfully!");
      console.log(`📋 Node ID: ${cliManager.getNodeId()}`);

      // Log alle node+plugin events naar console
      cliManager.onEvent((evt, data) => {
        console.log(`[Event] ${evt}:`, data);
      });

      // Houd de process alive tot SIGINT
      process.on("SIGINT", async () => {
        console.log("\n🛑 Shutting down...");
        await cliManager.stop();
        process.exit(0);
      });
    } catch (err: any) {
      console.error("❌ Failed to start node:", err.message);
      process.exit(1);
    }
  });

/**
 * `upload <file>`: upload een bestand vanaf schijf.
 *  - -s, --storage-mode <mode> (default: ipfs)
 */
program
  .command("upload <file>")
  .description("Upload a file to the network")
  .option("-s, --storage-mode <mode>", "Storage mode (ipfs or p2p-stream)", "ipfs")
  .action(async (filePath: string, options: any) => {
    try {
      const resolvedPath = path.resolve(filePath);
      if (!fs.existsSync(resolvedPath)) {
        console.error(`❌ File not found: ${resolvedPath}`);
        process.exit(1);
      }

      const cliManager = new CLIManager();

      await cliManager.start([], true);

      console.log(`📤 Uploading ${resolvedPath}...`);
      const fileBuffer = fs.readFileSync(resolvedPath);
      const fileName = path.basename(resolvedPath);
      const fileMime = (mime.lookup(fileName) as string) || "application/octet-stream";

      const nodeFile = new NodeFile(fileBuffer, fileName, fileMime);
      const cid = await cliManager.uploadFile(
        nodeFile,
        options.storageMode as "ipfs" | "p2p-stream",
      );
      console.log(`✅ File uploaded successfully!`);
      console.log(`📋 CID: ${cid}`);

      await cliManager.stop();
    } catch (err: any) {
      console.error(`❌ Upload failed: ${err.message}`);
      process.exit(1);
    }
  });

program
  .command("download <cid> <output>")
  .description("Download a file from the network")
  .action(async (cid: string, output: string) => {
    try {
      const resolvedPath = path.resolve(output);
      const cliManager = new CLIManager();

      await cliManager.start([], true);

      console.log(`📥 Downloading ${cid} to ${resolvedPath}...`);
      const data = await cliManager.downloadFile(cid);
      if (data) {
        fs.writeFileSync(resolvedPath, data);
        console.log("✅ File downloaded successfully!");
      } else {
        console.error("❌ Failed to download file (no data)");
      }

      await cliManager.stop();
    } catch (err: any) {
      console.error(`❌ Download failed: ${err.message}`);
      process.exit(1);
    }
  });

program
  .command("search <query>")
  .description("Search for files in the network")
  .action(async (query: string) => {
    try {
      console.log(`🔍 Searching for "${query}"...`);
      const cliManager = new CLIManager();

      await cliManager.start([], true);

      const results = await cliManager.searchFiles(query);
      console.log(`✅ Found ${results.length} results:\n`);
      results.forEach((file, idx) => {
        console.log(`${idx + 1}. ${file.name} (CID: ${file.cid})`);
        if ((file.metadata as any)?.artist) {
          console.log(`   Artist: ${(file.metadata as any).artist}`);
        }
        if ((file.metadata as any)?.album) {
          console.log(`   Album: ${(file.metadata as any).album}`);
        }
        console.log(`   Size: ${file.size} bytes`);
        console.log(`   Type: ${file.type}`);
        console.log(`   Peer: ${file.peerId.substring(0, 16)}...`);
        console.log(`   Availability: ${file.availability}\n`);
      });

      await cliManager.stop();
    } catch (err: any) {
      console.error(`❌ Search failed: ${err.message}`);
      process.exit(1);
    }
  });

program
  .command("pin <cid>")
  .description("Pin a file to keep it in local storage")
  .action(async (cid: string) => {
    try {
      console.log(`📌 Pinning ${cid}…`);
      const cliManager = new CLIManager();
      await cliManager.start([], true);

      await cliManager.pinFile(cid);
      console.log("✅ File pinned successfully!");

      await cliManager.stop();
    } catch (err: any) {
      console.error(`❌ Pin failed: ${err.message}`);
      process.exit(1);
    }
  });

program
  .command("unpin <cid>")
  .description("Unpin a file from local storage")
  .action(async (cid: string) => {
    try {
      console.log(`🗑️ Unpinning ${cid}…`);
      const cliManager = new CLIManager();
      await cliManager.start([], true);

      await cliManager.unpinFile(cid);
      console.log("✅ File unpinned successfully!");

      await cliManager.stop();
    } catch (err: any) {
      console.error(`❌ Unpin failed: ${err.message}`);
      process.exit(1);
    }
  });

program.parse(process.argv);

filename: packages/vinyl-peer-cli/src/NodeManager.ts
filecontent:
import { Vinyl, NodeStats, PeerInfo, StorageMode, NetworkFileInfo } from "vinyl-peer-protocol";
import * as fs from "fs";
import * as path from "path";
import { NodeFile } from "./Node.js";

export class NodeManager {
  private nodeService: Vinyl;
  private isRunning: boolean = false;

  /**
   * Now we expect a Vinyl instance to be passed in.
   */
  constructor(vinylInstance: Vinyl) {
    this.nodeService = vinylInstance;
  }

  async start(enableLocalStorage: boolean = true): Promise<void> {
    if (this.isRunning) {
      throw new Error("Node is already running");
    }

    const success = await this.nodeService.initialize(enableLocalStorage);
    if (!success) {
      throw new Error("Failed to initialize node");
    }

    this.isRunning = true;
  }

  async stop(): Promise<void> {
    if (!this.isRunning) {
      return;
    }

    await this.nodeService.stop();
    this.isRunning = false;
  }

  getNodeId(): string {
    return this.nodeService.getNodeStats().id;
  }

  getStats(): NodeStats {
    return this.nodeService.getNodeStats();
  }

  getPeers(): PeerInfo[] {
    return this.nodeService.getPeers();
  }

  async uploadFile(filePath: string, storageMode: StorageMode = "ipfs"): Promise<string> {
    if (!this.isRunning) {
      throw new Error("Node is not running. Start the node first with: npm run cli start");
    }

    if (!fs.existsSync(filePath)) {
      throw new Error(`File not found: ${filePath}`);
    }

    const fileBuffer = fs.readFileSync(filePath);
    const fileName = path.basename(filePath);

    // Wrap raw Buffer into our NodeFile abstraction:
    const mimeType = this.getMimeType(fileName);
    const nodeFile = new NodeFile(fileBuffer, fileName, mimeType);

    return await this.nodeService.uploadFile(nodeFile, storageMode);
  }

  async downloadFile(cid: string, outputPath: string): Promise<void> {
    if (!this.isRunning) {
      throw new Error("Node is not running. Start the node first with: npm run cli start");
    }

    const data = await this.nodeService.downloadFile(cid);
    if (!data) {
      throw new Error("Failed to download file");
    }

    fs.writeFileSync(outputPath, data);
  }

  async searchFiles(query: string): Promise<NetworkFileInfo[]> {
    if (!this.isRunning) {
      throw new Error("Node is not running. Start the node first with: npm run cli start");
    }

    return await this.nodeService.searchFiles(query);
  }

  async pinFile(cid: string): Promise<void> {
    if (!this.isRunning) {
      throw new Error("Node is not running. Start the node first with: npm run cli start");
    }

    await this.nodeService.pinFile(cid);
  }

  async unpinFile(cid: string): Promise<void> {
    if (!this.isRunning) {
      throw new Error("Node is not running. Start the node first with: npm run cli start");
    }

    await this.nodeService.unpinFile(cid);
  }

  private getMimeType(fileName: string): string {
    const ext = path.extname(fileName).toLowerCase();
    const mimeTypes: { [key: string]: string } = {
      ".mp3": "audio/mpeg",
      ".wav": "audio/wav",
      ".flac": "audio/flac",
      ".ogg": "audio/ogg",
      ".m4a": "audio/mp4",
      ".txt": "text/plain",
      ".json": "application/json",
      ".pdf": "application/pdf",
      ".jpg": "image/jpeg",
      ".jpeg": "image/jpeg",
      ".png": "image/png",
      ".gif": "image/gif",
    };
    return mimeTypes[ext] || "application/octet-stream";
  }

  isNodeRunning(): boolean {
    return this.isRunning;
  }
}

filename: packages/vinyl-peer-plugin-filecoin-bridge/tsconfig.esm.json
filecontent:
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "module": "ESNext",                // produce ESM
    "target": "ES2020",                // or whatever target you prefer
    "outDir": "dist/esm",              // everything goes under dist/esm
    "declaration": true,               // emit .d.ts files
    "declarationDir": "dist/esm",      // put .d.ts next to .js
    "strict": true,
    "esModuleInterop": true,
    "moduleResolution": "node",
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}

filename: packages/vinyl-peer-plugin-filecoin-bridge/package.json
filecontent:
{
  "name": "vinyl-peer-plugin-filecoin-bridge",
  "version": "0.0.1",
  "authors": [
    "KDLabs"
  ],
  "type": "module",
  "main": "dist/cjs/index.js",
  "module": "dist/esm/index.js",
  "types": "dist/esm/index.d.ts",
  "exports": {
    "import": "./dist/esm/index.js",
    "require": "./dist/cjs/index.js"
  },
  "scripts": {
    "build:esm": "tsc -p tsconfig.esm.json",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build": "rimraf dist && npm run build:esm && npm run build:cjs",
    "test": "vitest"
  },
  "dependencies": {
    "@ipld/car": "^5.4.2",
    "express": "^4.18.2",
    "multiformats": "^13.3.6",
    "ts-retry-promise": "^0.8.1",
    "vinyl-peer-protocol": "workspace:*",
    "web3.storage": "^4.5.5",
    "@helia/unixfs": "^5.0.3"
  },
  "devDependencies": {
    "@types/express": "^5.0.2",
    "@types/node": "^18.7.23",
    "typescript": "^5.7.3",
    "vitest": "^3.0.5"
  }
}

filename: packages/vinyl-peer-plugin-filecoin-bridge/tsconfig.cjs.json
filecontent:
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "module": "CommonJS",     // produce CJS
    "target": "ES2020",       
    "outDir": "dist/cjs",     // everything goes under dist/cjs
    "declaration": false      // we don’t need .d.ts here (we already emitted them under dist/esm)
  },
  "include": ["src/**/*"]
}

filename: packages/vinyl-peer-plugin-filecoin-bridge/src/FileCoinBridgePlugin.ts
filecontent:
import {
  BasePlugin,
  PluginCapabilities,
  PluginContext,
  VinylPeerPlugin,
} from "vinyl-peer-protocol";
import { Web3Storage } from "web3.storage";
import { CarWriter } from "@ipld/car";
import { CID } from "multiformats/cid";
import { retry } from "ts-retry-promise";
import { FileInfo } from "vinyl-peer-protocol";
import { Buffer } from "buffer";
import { unixfs } from "@helia/unixfs";

/**
 * FilecoinBridgePlugin:
 *  1) Listens for “archiveRequested” (metadata CID) events.
 *  2) Uses UnixFS (fs = unixfs(this.context.helia)) to fetch metadata JSON.
 *  3) Parses out `storedCID` (the encrypted‐payload CID).
 *  4) Uses UnixFS again to stream the encrypted payload block.
 *  5) Wraps that block in a CAR and uploads to Web3.Storage.
 *  6) Updates LevelDB’s FileInfo.metadata with filecoinRoot + archivedAt.
 */
export class FilecoinBridgePlugin extends BasePlugin implements VinylPeerPlugin {
  protected context!: PluginContext;
  private client: Web3Storage;
  private defaultRetries = 3;
  private retryDelay = 2000; // ms

  constructor(token: string) {
    super();
    this.client = new Web3Storage({ token });
  }

  getCapabilities(): PluginCapabilities {
    return {
      name: "vinyl-peer-plugin-filecoin-bridge",
      version: "0.1.0",
      protocols: [], // No custom libp2p protocols
      capabilities: ["storage"],
      permissions: {
        accessFiles: true, // read/write to fileDb
        useNetwork: true, // dialing Helia/IPFS is allowed
        modifyPeers: false,
        exposeHttp: false,
      },
    };
  }

  async initialize(context: PluginContext): Promise<boolean> {
    const ok = await super.initialize(context);
    if (!ok) return false;
    this.context = context;

    // Subscribe to "archiveRequested". Expect `payload = { cid: string }`.
    this.context.onEvent((event, envelope) => {
      if (event === "archiveRequested") {
        const { cid } = envelope.payload as { cid: string };
        this.archiveToFilecoin(cid).catch((err) => {
          console.error(`[FilecoinBridge] archiveToFilecoin failed for ${cid}:`, err);
        });
      }
    });

    return true;
  }

  async start(): Promise<void> {
    // No startup logic needed
  }

  async stop(): Promise<void> {
    await super.stop();
  }

  setupProtocols(): void {
    // No libp2p protocols
  }

  async handleProtocol(_protocol: string, _stream: any, _peerId: string): Promise<void> {
    // Not used
  }

  private async archiveToFilecoin(metadataCid: string): Promise<void> {
    try {
      // Instantiate UnixFS against the Helia instance
      const fs = unixfs(this.context.helia);

      // ── Step 1: Fetch the metadata JSON from IPFS/Helia ──
      //
      //   The “metadata CID” points to a JSON blob that looks like:
      //     {
      //       name: string,
      //       size: number,
      //       type: string,
      //       uploadDate: ISOString,
      //       storageMode: "ipfs" | "p2p-stream",
      //       storedCID: "<cid-of-encrypted-bytes>",
      //       metadata: { … }
      //     }
      //
      const metaChunks: Uint8Array[] = [];
      const metadataCidObj = CID.parse(metadataCid);
      for await (const chunk of fs.cat(metadataCidObj)) {
        metaChunks.push(chunk);
      }
      const metaBuf = Buffer.concat(metaChunks.map((u) => Buffer.from(u)));
      const metaJson = metaBuf.toString("utf-8");

      let parsedMeta: any;
      try {
        parsedMeta = JSON.parse(metaJson);
      } catch (e) {
        console.error(`[FilecoinBridge] invalid JSON for metadataCID ${metadataCid}`, e);
        return;
      }

      const storedCID: string | undefined = parsedMeta.storedCID;
      if (!storedCID) {
        console.warn(`[FilecoinBridge] metadata JSON for ${metadataCid} lacks "storedCID"`);
        return;
      }

      // ── Step 2: Ensure storageMode is "ipfs" (otherwise, cannot archive p2p streams) ──
      if (parsedMeta.storageMode !== "ipfs") {
        console.warn(
          `[FilecoinBridge] cannot archive metadataCid ${metadataCid} because storageMode="${parsedMeta.storageMode}"`,
        );
        return;
      }

      // ── Step 3: Stream the encrypted payload bytes from IPFS/Helia ──
      const encryptedChunks: Uint8Array[] = [];
      const storedCidObj = CID.parse(storedCID);
      for await (const chunk of fs.cat(storedCidObj)) {
        encryptedChunks.push(chunk);
      }
      const encryptedBuffer = Buffer.concat(encryptedChunks.map((u) => Buffer.from(u)));

      // ── Step 4: Wrap that encrypted block into a CAR and upload to Web3.Storage ──
      const uploadCid = await retry(
        async () => {
          // Create a CAR writer containing exactly one block whose CID is `storedCID`,
          // and whose bytes are the encryptedBuffer.
          const blockCid = CID.parse(storedCID);
          const { writer, out } = await CarWriter.create([blockCid]);
          await writer.put({ cid: blockCid, bytes: encryptedBuffer });
          writer.close();

          // Collect all CAR chunks into one Buffer
          const carChunks: Uint8Array[] = [];
          for await (const c of out) {
            carChunks.push(c);
          }
          const fullCarBuf = Buffer.concat(carChunks.map((u) => Buffer.from(u)));

          // Convert that Buffer into a Blob, then into a File
          const carBlob = new Blob([fullCarBuf], { type: "application/car" });
          const carFile = new File([carBlob], `${metadataCid}.car`, { type: "application/car" });

          // Upload that single‐File CAR to Web3.Storage
          const rootCid = await this.client.put([carFile], {
            wrapWithDirectory: false,
          });
          console.log(`[FilecoinBridge] Archived ${storedCID} → Filecoin/IPFS CID ${rootCid}`);

          // ── Step 5: Annotate LevelDB’s FileInfo.metadata ──
          const existing: FileInfo | undefined = await this.context.fileDb
            .get(metadataCid)
            .catch(() => undefined);
          if (existing) {
            if (typeof existing.metadata !== "object" || existing.metadata === null) {
              existing.metadata = {};
            }
            existing.metadata.filecoinRoot = rootCid;
            existing.metadata.archivedAt = new Date().toISOString();
            await this.context.fileDb.put(metadataCid, existing);
          } else {
            console.warn(
              `[FilecoinBridge] no FileInfo found for metadataCid ${metadataCid}, skipping metadata update`,
            );
          }

          return rootCid;
        },
        {
          retries: this.defaultRetries,
          delay: this.retryDelay,
          backoff: "EXPONENTIAL",
        },
      ).catch((err) => {
        console.error(`[FilecoinBridge] final failure after retries for ${metadataCid}:`, err);
        return null;
      });

      if (!uploadCid) {
        console.error(`[FilecoinBridge] failed to archive ${metadataCid} after retries`);
      }
    } catch (err) {
      console.error(`[FilecoinBridge] unexpected error in archiveToFilecoin:`, err);
    }
  }
}

filename: packages/vinyl-peer-plugin-filecoin-bridge/src/index.ts
filecontent:
export * from "./FileCoinBridgePlugin.js";

filename: packages/vinyl-peer-plugin-music/tsconfig.esm.json
filecontent:
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "module": "ESNext",                // produce ESM
    "target": "ES2020",                // or whatever target you prefer
    "outDir": "dist/esm",              // everything goes under dist/esm
    "declaration": true,               // emit .d.ts files
    "declarationDir": "dist/esm",      // put .d.ts next to .js
    "strict": true,
    "esModuleInterop": true,
    "moduleResolution": "node",
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}

filename: packages/vinyl-peer-plugin-music/package.json
filecontent:
{
  "name": "vinyl-peer-plugin-music",
  "version": "0.0.1",
  "authors": [
    "KDLabs"
  ],
  "type": "module",
  "main": "dist/cjs/index.js",
  "module": "dist/esm/index.js",
  "types": "dist/esm/index.d.ts",
  "exports": {
    "import": "./dist/esm/index.js",
    "require": "./dist/cjs/index.js"
  },
  "scripts": {
    "build:esm": "tsc -p tsconfig.esm.json",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build": "rimraf dist && npm run build:esm && npm run build:cjs",
    "test": "vitest"
  },
  "dependencies": {
    "express": "^5.1.0",
    "mime-types": "^2.1.34",
    "multer": "^1.4.5-lts.1",
    "@helia/unixfs": "^5.0.3",
    "multiformats": "^13.3.6",
    "vinyl-peer-protocol": "workspace:*"
  },
  "devDependencies": {
    "@types/mime-types": "^2.1.0",
    "@types/multer": "^1.4.7",
    "@types/express": "^5.0.2",
    "@types/node": "^18.7.23",
    "typescript": "^5.7.3",
    "vitest": "^3.0.5"
  }
}

filename: packages/vinyl-peer-plugin-music/tsconfig.cjs.json
filecontent:
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "module": "CommonJS",     // produce CJS
    "target": "ES2020",       
    "outDir": "dist/cjs",     // everything goes under dist/cjs
    "declaration": false      // we don’t need .d.ts here (we already emitted them under dist/esm)
  },
  "include": ["src/**/*"]
}

filename: packages/vinyl-peer-plugin-music/src/types.ts
filecontent:
/**
 * MusicMetadata: All fields known about an audio file.
 */
export interface MusicMetadata {
  artist?: string;
  album?: string;
  title?: string;
  genre?: string;
  year?: number;
  duration?: number; // seconds
  bpm?: number;
  mood?: string;
  tags?: string[];
}

/**
 * MusicDiscoveryQuery: Filter parameters for searching music.
 */
export interface MusicDiscoveryQuery {
  artist?: string;
  album?: string;
  genre?: string;
  mood?: string;
  bpm?: { min: number; max: number };
  year?: { min: number; max: number };
  limit?: number;
}

/**
 * MusicRecommendation: Returned recommendation object.
 */
export interface MusicRecommendation {
  cid: string;
  score: number;
  reason: string;
  metadata: MusicMetadata;
}

/**
 * Playlist entry.
 */
export interface Playlist {
  name: string;
  ownerPeer: string;
  trackCids: string[];
  createdAt: string;
  updatedAt: string;
}

/**
 * Announcement payload for PubSub.
 */
export interface AnnouncementPayload {
  type: "new-track";
  cid: string;
  metadata: MusicMetadata;
  peerId: string;
}

filename: packages/vinyl-peer-plugin-music/src/MusicPlugin.ts
filecontent:
import express, { Router, RequestHandler } from "express";
import { CID } from "multiformats/cid";
import {
  BasePlugin,
  PluginCapabilities,
  PluginContext,
  VinylPeerPlugin,
  PeerInfo,
  FileInfo,
  NetworkFileInfo,
  UploadFile,
} from "vinyl-peer-protocol";
import { unixfs } from "@helia/unixfs";
import multer from "multer";
import mime from "mime-types";
import type { MusicMetadata, MusicDiscoveryQuery, AnnouncementPayload, Playlist } from "./types.js";
export class MusicPlugin extends BasePlugin implements VinylPeerPlugin {
  protected context!: PluginContext;

  // In-memory caches
  private musicMetadata: Map<string, MusicMetadata> = new Map();
  private genreGraph: Map<string, string[]> = new Map();
  private musicPeers: Set<string> = new Set();
  private discoveredTracks: Map<string, { peerId: string; metadata: MusicMetadata }> = new Map();
  private playlists: Map<string, Playlist> = new Map();

  // Multer for file uploads
  private upload: multer.Multer;

  // PubSub topic for announcements
  private readonly ANNOUNCE_TOPIC = "/music-announcements/1.0.0";

  constructor() {
    super();
    this.initializeMusicKnowledge();
    this.upload = multer({ storage: multer.memoryStorage() });
  }

  /** Declare plugin identity, protocols, capabilities, fileTypes, permissions */
  getCapabilities(): PluginCapabilities {
    return {
      name: "vinyl-peer-plugin-music-network",
      version: "1.0.0",
      protocols: [
        "/music-discovery/1.0.0",
        "/music-recommendations/1.0.0",
        "/music-metadata/1.0.0",
        "/music-stream/1.0.0",
      ],
      capabilities: ["streaming", "discovery", "recommendations", "metadata", "upload", "playlist"],
      fileTypes: ["audio/*"],
      permissions: {
        accessFiles: true,
        useNetwork: true,
        modifyPeers: true,
        exposeHttp: true,
      },
    };
  }

  /** Build genreGraph for heuristic recommendations */
  private initializeMusicKnowledge(): void {
    this.genreGraph.set("rock", ["alternative", "indie", "punk", "metal"]);
    this.genreGraph.set("electronic", ["techno", "house", "ambient", "dubstep"]);
    this.genreGraph.set("jazz", ["blues", "fusion", "swing", "bebop"]);
    this.genreGraph.set("classical", ["baroque", "romantic", "contemporary"]);
    this.genreGraph.set("hip-hop", ["rap", "trap", "old-school"]);
    this.genreGraph.set("folk", ["country", "bluegrass", "acoustic"]);
    this.genreGraph.set("urban", ["rnb", "soul", "funk"]);
  }

  async initialize(context: PluginContext): Promise<boolean> {
    const ok = await super.initialize(context);
    if (!ok) return false;
    this.context = context;

    // Subscribe to PubSub announcements
    const pubsub = this.context.libp2p.services.pubsub;
    if (pubsub) {
      await pubsub.subscribe(this.ANNOUNCE_TOPIC);
      pubsub.addEventListener("message", (evt: any) => {
        if (evt.detail.topic !== this.ANNOUNCE_TOPIC) return;
        try {
          const msg = JSON.parse(new TextDecoder().decode(evt.detail.data)) as AnnouncementPayload;
          if (msg.type === "new-track") {
            const { cid, metadata, peerId } = msg;
            // store discovered track
            this.discoveredTracks.set(cid, { peerId, metadata });
          }
        } catch {
          // ignore
        }
      });
    }

    return true;
  }

  async start(): Promise<void> {
    await super.start();
    // Periodically attempt to identify music-capable peers
    this.startPeerDiscovery();
  }

  async stop(): Promise<void> {
    await super.stop();
  }

  /** No-op to avoid double registration */
  setupProtocols(): void {}

  /** Handle incoming libp2p protocol streams */
  async handleProtocol(protocol: string, stream: any, peerId: string): Promise<void> {
    switch (protocol) {
      case "/music-discovery/1.0.0":
        await this.handleMusicDiscoveryRequest(stream, peerId);
        break;
      case "/music-recommendations/1.0.0":
        await this.handleRecommendationRequest(stream, peerId);
        break;
      case "/music-metadata/1.0.0":
        await this.handleMetadataRequest(stream, peerId);
        break;
      case "/music-stream/1.0.0":
        await this.handleStreamRequest(stream, peerId);
        break;
      default:
        break;
    }
  }

  /** Return true if file is audio based on MIME type */
  canHandleFile(file: FileInfo): boolean {
    return file.type.startsWith("audio/");
  }

  /**
   * Enhance metadata for a newly uploaded file by parsing filename patterns:
   * - "Artist - Album - Title"
   * - "Artist - Title"
   * - Extract year
   * - Guess genre
   */
  async enhanceMetadata(file: UploadFile): Promise<MusicMetadata> {
    if (!file || file.size === 0) {
      throw new Error("MusicNetworkPlugin: Invalid file provided");
    }
    const metadata: MusicMetadata = {};
    const fileNameWithoutExt = file.name.replace(/\.[^/.]+$/, "");

    // Pattern: Artist - Album - Title
    const tripleMatch = fileNameWithoutExt.match(/^(.+?)\s*-\s*(.+?)\s*-\s*(.+?)$/);
    if (tripleMatch) {
      metadata.artist = tripleMatch[1].trim();
      metadata.album = tripleMatch[2].trim();
      metadata.title = tripleMatch[3].trim();
    } else {
      // Pattern: Artist - Title
      const duoMatch = fileNameWithoutExt.match(/^(.+?)\s*-\s*(.+?)$/);
      if (duoMatch) {
        metadata.artist = duoMatch[1].trim();
        metadata.title = duoMatch[2].trim();
      } else {
        metadata.title = fileNameWithoutExt;
      }
    }

    // Extract year if present
    const yearMatch = fileNameWithoutExt.match(/\b(19|20)\d{2}\b/);
    if (yearMatch) {
      metadata.year = parseInt(yearMatch[0], 10);
    }

    // Guess genre
    const lowerName = fileNameWithoutExt.toLowerCase();
    for (const [genre, keywords] of this.genreGraph.entries()) {
      if (keywords.some((kw) => lowerName.includes(kw))) {
        metadata.genre = genre;
        break;
      }
    }

    return metadata;
  }

  /** Search local + discovered tracks according to MusicDiscoveryQuery */
  async searchFiles(query: any): Promise<NetworkFileInfo[]> {
    if (!this.context) {
      throw new Error("MusicNetworkPlugin: missing context");
    }
    if (typeof query !== "object") {
      throw new Error("MusicNetworkPlugin: Invalid search query provided");
    }
    const q = query as MusicDiscoveryQuery;
    const results: NetworkFileInfo[] = [];

    // Local files
    for (const file of Array.from(this.context.files.values())) {
      if (!this.canHandleFile(file) || !file.metadata) continue;
      let score = 0;
      const md = file.metadata as MusicMetadata;

      if (q.artist && md.artist) {
        if (md.artist.toLowerCase().includes(q.artist.toLowerCase())) {
          score += 10;
        }
      }
      if (q.album && md.album) {
        if (md.album.toLowerCase().includes(q.album.toLowerCase())) {
          score += 8;
        }
      }
      if (q.genre && md.genre) {
        if (md.genre.toLowerCase() === q.genre.toLowerCase()) {
          score += 7;
        } else if (this.isRelatedGenre(md.genre, q.genre)) {
          score += 4;
        }
      }
      if (score > 0) {
        results.push({
          ...file,
          peerId: this.context.nodeId,
          peerAddress: "local",
          availability: "online",
        });
      }
    }

    // Discovered remote tracks
    for (const [cid, { peerId, metadata }] of this.discoveredTracks.entries()) {
      let score = 0;
      if (q.artist && metadata.artist) {
        if (metadata.artist.toLowerCase().includes(q.artist.toLowerCase())) {
          score += 10;
        }
      }
      if (q.album && metadata.album) {
        if (metadata.album.toLowerCase().includes(q.album.toLowerCase())) {
          score += 8;
        }
      }
      if (q.genre && metadata.genre) {
        if (metadata.genre.toLowerCase() === q.genre.toLowerCase()) {
          score += 7;
        } else if (this.isRelatedGenre(metadata.genre, q.genre)) {
          score += 4;
        }
      }
      if (score > 0) {
        results.push({
          cid,
          name: metadata.title || cid,
          size: 0, // unknown for remote
          type: "audio/unknown",
          uploadDate: new Date(),
          encrypted: false,
          storageMode: "ipfs",
          streamId: undefined,
          pinned: false,
          shareLink: `vinyl://ipfs/${cid}`,
          metadata,
          peerId,
          peerAddress: "network",
          availability: "online",
        });
      }
    }

    return results;
  }

  /** Provide recommendations based on shared metadata heuristics */
  async getRecommendations(basedOnCid: string): Promise<NetworkFileInfo[]> {
    if (!this.context) {
      throw new Error("MusicNetworkPlugin: missing context");
    }
    const candidates: Array<NetworkFileInfo & { _score: number }> = [];
    let baseMetadata: MusicMetadata | undefined;
    let basePeerId: string | undefined;

    // Check local first
    const baseLocal = this.context.files.get(basedOnCid);
    if (baseLocal && baseLocal.metadata) {
      baseMetadata = baseLocal.metadata as MusicMetadata;
      basePeerId = this.context.nodeId;
    } else if (this.discoveredTracks.has(basedOnCid)) {
      const rec = this.discoveredTracks.get(basedOnCid)!;
      baseMetadata = rec.metadata;
      basePeerId = rec.peerId;
    }

    if (!baseMetadata) {
      throw new Error(`MusicNetworkPlugin: Base file ${basedOnCid} not found`);
    }

    const evaluate = (
      file: FileInfo | { cid: string; metadata: MusicMetadata; peerId: string },
    ) => {
      let score = 0;
      const md = ("metadata" in file ? file.metadata : file.metadata) as MusicMetadata;
      // Same artist
      if (baseMetadata!.artist && md.artist === baseMetadata!.artist) {
        score += 15;
      }
      // Same genre
      if (baseMetadata!.genre && md.genre === baseMetadata!.genre) {
        score += 10;
      } else if (
        baseMetadata!.genre &&
        md.genre &&
        this.isRelatedGenre(baseMetadata!.genre, md.genre)
      ) {
        score += 6;
      }
      return score;
    };

    // Local candidates
    for (const file of Array.from(this.context.files.values())) {
      if (file.cid === basedOnCid || !this.canHandleFile(file) || !file.metadata) continue;
      const sc = evaluate(file);
      if (sc >= 5) {
        candidates.push({
          ...file,
          peerId: this.context.nodeId,
          peerAddress: "local",
          availability: "online",
          _score: sc,
        });
      }
    }

    // Remote candidates
    for (const [cid, rec] of this.discoveredTracks.entries()) {
      if (cid === basedOnCid) continue;
      const sc = evaluate({ cid, metadata: rec.metadata, peerId: rec.peerId });
      if (sc >= 5) {
        candidates.push({
          cid,
          name: rec.metadata.title || cid,
          size: 0,
          type: "audio/unknown",
          uploadDate: new Date(),
          encrypted: false,
          storageMode: "ipfs",
          streamId: undefined,
          pinned: false,
          shareLink: `vinyl://ipfs/${cid}`,
          metadata: rec.metadata,
          peerId: rec.peerId,
          peerAddress: "network",
          availability: "online",
          _score: sc,
        } as NetworkFileInfo & { _score: number });
      }
    }

    candidates.sort((a, b) => (b as any)._score - (a as any)._score);
    return candidates.slice(0, 10).map((c) => {
      delete (c as any)._score;
      return c;
    });
  }

  /** Check if two genres are related via genreGraph */
  private isRelatedGenre(g1: string, g2: string): boolean {
    const rel1 = this.genreGraph.get(g1.toLowerCase()) || [];
    const rel2 = this.genreGraph.get(g2.toLowerCase()) || [];
    return rel1.includes(g2.toLowerCase()) || rel2.includes(g1.toLowerCase());
  }

  /** Called when a peer connects: attempt to identify as music peer via custom protocol */
  onPeerConnected(peerId: string, peer: PeerInfo): void {
    if (!this.context || !this.context.libp2p.isStarted) return;
    this.context.libp2p
      .dialProtocol(peerId, "/music-network/1.0.0")
      .then(() => {
        this.musicPeers.add(peerId);
      })
      .catch(() => {
        // not a music peer
      });
  }

  /** Called when a peer disconnects: remove from musicPeers */
  onPeerDisconnected(peerId: string, peer: PeerInfo): void {
    this.musicPeers.delete(peerId);
  }

  /** Called when a file is uploaded: store metadata, announce, index */
  async onFileUploaded(cid: string, fileInfo: FileInfo): Promise<void> {
    if (this.canHandleFile(fileInfo) && fileInfo.metadata) {
      const md = fileInfo.metadata as MusicMetadata;
      this.musicMetadata.set(cid, md);
      // Announce to network
      const pubsub = this.context.libp2p.services.pubsub;
      if (pubsub) {
        const payload: AnnouncementPayload = {
          type: "new-track",
          cid,
          metadata: md,
          peerId: this.context.nodeId,
        };
        pubsub
          .publish(this.ANNOUNCE_TOPIC, new TextEncoder().encode(JSON.stringify(payload)))
          .catch(() => {});
      }
    }
  }

  /** Called when a file is downloaded: no-op */
  onFileDownloaded(cid: string): void {
    // could track metrics or demand
  }

  // ─── HTTP ROUTES ───

  getHttpNamespace(): string {
    return "/api/music";
  }

  getHttpRouter(): Router {
    const router = Router();

    // — Upload endpoint
    router.post("/upload", this.upload.single("file"), this.handleHttpUpload());

    // — Search endpoint
    router.post("/search", this.handleHttpSearch());

    // — Recommendations endpoint
    router.get("/recommendations/:cid", this.handleHttpRecommend());

    // — Metadata retrieval
    router.get("/metadata/:cid", this.handleHttpMetadata());

    // — List all local music
    router.get("/all", this.handleHttpListAll());

    // — Stats endpoint
    router.get("/stats", this.handleHttpStats());

    // — Stream endpoint (HTTP range support)
    router.get("/stream/:cid", this.handleHttpStream());

    // — Playlist endpoints
    router.post("/playlist", express.json(), this.handleCreatePlaylist());
    router.get("/playlist/:name", this.handleGetPlaylist());
    router.put("/playlist/:name", express.json(), this.handleUpdatePlaylist());
    router.delete("/playlist/:name", this.handleDeletePlaylist());

    return router;
  }

  /** Handle HTTP upload: store on Helia/IPFS, index in fileDb, emit events */
  private handleHttpUpload(): RequestHandler {
    return async (req, res) => {
      try {
        const file = req.file;
        if (!file || !file.buffer) {
          res.status(400).json({ error: "Missing file (field=name='file')" });
          return;
        }

        // Enhance metadata
        const md = await this.enhanceMetadata({
          name: file.originalname,
          size: file.size,
          type: file.mimetype || "application/octet-stream",
          arrayBuffer: async () => {
            const ab = new ArrayBuffer(file.buffer.byteLength);
            new Uint8Array(ab).set(file.buffer);
            return ab;
          },
        });

        // Add bytes to Helia/IPFS

        const fs = unixfs(this.context.helia);
        const cidObj = await fs.addBytes(file.buffer);
        const cidStr = cidObj.toString();

        // Build FileInfo
        const mimeType =
          file.mimetype || (mime.lookup(file.originalname) as string) || "application/octet-stream";
        const fileInfo: FileInfo = {
          cid: cidStr,
          name: file.originalname,
          size: file.size,
          type: mimeType,
          uploadDate: new Date(),
          encrypted: false,
          storageMode: "ipfs",
          streamId: undefined,
          pinned: false,
          shareLink: `vinyl://ipfs/${cidStr}`,
          metadata: md,
        };

        // Persist FileInfo in LevelDB
        await this.context.fileDb.put(cidStr, fileInfo);

        // Notify core/UI
        this.context.emit("fileUploaded", { source: "music-plugin", payload: cidStr });

        res.json({ cid: cidStr, metadata: md });
      } catch (err: any) {
        console.error("[MusicNetworkPlugin] upload failed:", err);
        res.status(500).json({ error: err.message });
      }
    };
  }

  /** Handle HTTP search */
  private handleHttpSearch(): RequestHandler {
    return async (req, res) => {
      try {
        const query = req.body as MusicDiscoveryQuery;
        const results = await this.searchFiles(query);
        res.json({ results });
      } catch (err: any) {
        res.status(400).json({ error: err.message });
      }
    };
  }

  /** Handle HTTP recommendations */
  private handleHttpRecommend(): RequestHandler {
    return async (req, res) => {
      try {
        const { cid } = req.params;
        const recs = await this.getRecommendations(cid);
        res.json({ recommendations: recs });
      } catch (err: any) {
        res.status(500).json({ error: err.message });
      }
    };
  }

  /** Handle HTTP metadata retrieval */
  private handleHttpMetadata(): RequestHandler {
    return (req, res) => {
      try {
        const { cid } = req.params;
        let md: MusicMetadata | undefined;
        // check local
        const local = this.context.fileDb.get(cid).catch(() => undefined);
        Promise.resolve(local).then((fi) => {
          if (fi && fi.metadata) {
            md = fi.metadata as MusicMetadata;
            res.json(md);
          } else if (this.discoveredTracks.has(cid)) {
            md = this.discoveredTracks.get(cid)!.metadata;
            res.json(md);
          } else {
            res.status(404).json({ error: `Metadata not found for ${cid}` });
          }
        });
      } catch (err: any) {
        res.status(500).json({ error: err.message });
      }
    };
  }

  /** Handle HTTP list all local music files */
  private handleHttpListAll(): RequestHandler {
    return async (_req, res) => {
      try {
        const all = Array.from(this.context.files.values()).filter((f) => this.canHandleFile(f));
        res.json({ files: all });
      } catch (err: any) {
        res.status(500).json({ error: err.message });
      }
    };
  }

  /** Handle HTTP stats: total files, genre distribution, top artists, connected peers */
  private handleHttpStats(): RequestHandler {
    return (_req, res) => {
      try {
        const stats = this.getMusicStats();
        res.json(stats);
      } catch (err: any) {
        res.status(500).json({ error: err.message });
      }
    };
  }

  private handleHttpStream(): RequestHandler {
    return async (req, res) => {
      try {
        const { cid: cidStr } = req.params;

        // 1. Parse the string into a CID instance
        const cidObj = CID.parse(cidStr);

        // 2. Wrap Helia in UnixFS and stream the file by CID
        const fs = unixfs(this.context.helia);
        const chunks: Uint8Array[] = [];
        for await (const chunk of fs.cat(cidObj)) {
          chunks.push(chunk);
        }
        const fullBuffer = Buffer.concat(chunks.map((u) => Buffer.from(u)));

        // 3. Support HTTP Range requests as before
        const range = req.headers.range;
        const fileSize = fullBuffer.length;
        const contentType = mime.lookup(cidStr) || "audio/mpeg";

        if (range) {
          const parts = range.replace(/bytes=/, "").split("-");
          const start = parseInt(parts[0], 10);
          const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1;
          const chunkSize = end - start + 1;
          const streamBuffer = fullBuffer.slice(start, end + 1);

          res.writeHead(206, {
            "Content-Range": `bytes ${start}-${end}/${fileSize}`,
            "Accept-Ranges": "bytes",
            "Content-Length": chunkSize,
            "Content-Type": contentType,
          });
          res.end(streamBuffer);
        } else {
          res.writeHead(200, {
            "Content-Length": fileSize,
            "Content-Type": contentType,
          });
          res.end(fullBuffer);
        }
      } catch (err: any) {
        console.error("[MusicNetworkPlugin] stream error:", err);
        res.status(404).json({ error: "Stream not available" });
      }
    };
  }

  /** Handle HTTP create playlist */
  private handleCreatePlaylist(): RequestHandler {
    return async (req, res) => {
      try {
        const { name, trackCids } = req.body as {
          name: string;
          trackCids: string[];
        };
        if (!name || !Array.isArray(trackCids)) {
          res.status(400).json({ error: "Invalid payload" });
          return;
        }
        const playlist: Playlist = {
          name,
          ownerPeer: this.context.nodeId,
          trackCids,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
        };
        this.playlists.set(name, playlist);
        res.json({ success: true, playlist });
      } catch (err: any) {
        res.status(500).json({ error: err.message });
      }
    };
  }

  /** Handle HTTP get playlist */
  private handleGetPlaylist(): RequestHandler {
    return (req, res) => {
      try {
        const { name } = req.params;
        const pl = this.playlists.get(name);
        if (!pl) {
          res.status(404).json({ error: `Playlist ${name} not found` });
          return;
        }
        res.json(pl);
      } catch (err: any) {
        res.status(500).json({ error: err.message });
      }
    };
  }

  /** Handle HTTP update playlist */
  private handleUpdatePlaylist(): RequestHandler {
    return (req, res) => {
      try {
        const { name } = req.params;
        const pl = this.playlists.get(name);
        if (!pl) {
          res.status(404).json({ error: `Playlist ${name} not found` });
          return;
        }
        const { trackCids } = req.body as { trackCids: string[] };
        if (!Array.isArray(trackCids)) {
          res.status(400).json({ error: "Invalid payload" });
          return;
        }
        pl.trackCids = trackCids;
        pl.updatedAt = new Date().toISOString();
        this.playlists.set(name, pl);
        res.json({ success: true, playlist: pl });
      } catch (err: any) {
        res.status(500).json({ error: err.message });
      }
    };
  }

  /** Handle HTTP delete playlist */
  private handleDeletePlaylist(): RequestHandler {
    return (req, res) => {
      try {
        const { name } = req.params;
        if (!this.playlists.has(name)) {
          res.status(404).json({ error: `Playlist ${name} not found` });
          return;
        }
        this.playlists.delete(name);
        res.json({ success: true });
      } catch (err: any) {
        res.status(500).json({ error: err.message });
      }
    };
  }

  // ─── Internal Protocol Handlers ───

  private async handleMusicDiscoveryRequest(stream: any, peerId: string) {
    try {
      const chunks: Uint8Array[] = [];
      for await (const chunk of stream.source) {
        chunks.push(chunk);
      }
      const data = new TextDecoder().decode(chunks[0]);
      const query: MusicDiscoveryQuery = JSON.parse(data);
      const results = await this.searchFiles(query);
      const response = JSON.stringify({ type: "discovery-results", results });
      await stream.sink([new TextEncoder().encode(response)]);
    } catch (err: any) {
      console.error("MusicNetworkPlugin: Discovery error:", err);
    }
  }

  private async handleRecommendationRequest(stream: any, peerId: string) {
    try {
      const chunks: Uint8Array[] = [];
      for await (const chunk of stream.source) {
        chunks.push(chunk);
      }
      const data = new TextDecoder().decode(chunks[0]);
      const request = JSON.parse(data);
      if (request.type === "recommendation-request" && request.basedOn) {
        const recs = await this.getRecommendations(request.basedOn);
        const response = JSON.stringify({
          type: "recommendations",
          recommendations: recs,
        });
        await stream.sink([new TextEncoder().encode(response)]);
      }
    } catch (err: any) {
      console.error("MusicNetworkPlugin: Recommendation error:", err);
    }
  }

  private async handleMetadataRequest(stream: any, peerId: string) {
    try {
      const chunks: Uint8Array[] = [];
      for await (const chunk of stream.source) {
        chunks.push(chunk);
      }
      const data = new TextDecoder().decode(chunks[0]);
      const request = JSON.parse(data);
      if (request.type === "metadata-request" && request.cid) {
        const mdLocal = this.musicMetadata.get(request.cid) || null;
        const mdRemote = this.discoveredTracks.get(request.cid)?.metadata || null;
        const metadata = mdLocal || mdRemote;
        const response = JSON.stringify({
          type: "metadata-response",
          cid: request.cid,
          metadata,
        });
        await stream.sink([new TextEncoder().encode(response)]);
      }
    } catch (err: any) {
      console.error("MusicNetworkPlugin: Metadata error:", err);
    }
  }

  private async handleStreamRequest(stream: any, peerId: string) {
    try {
      // 1. Read the incoming request payload
      const chunks: Uint8Array[] = [];
      for await (const chunk of stream.source) {
        chunks.push(chunk);
      }
      const data = new TextDecoder().decode(chunks[0]);
      const request = JSON.parse(data);

      if (request.type === "stream-request" && request.cid) {
        // 2. Wrap Helia in UnixFS and fetch the file by CID
        const fs = unixfs(this.context.helia);
        for await (const dataChunk of fs.cat(request.cid)) {
          // 3. Send each chunk back to the requester
          await stream.sink([dataChunk]);
        }
      }
    } catch (err: any) {
      console.error("MusicNetworkPlugin: Stream error:", err);
    }
  }

  /** Entry point: connect to peers and announce this node supports music‐network protocol */
  private startPeerDiscovery(): void {
    setInterval(async () => {
      if (this.context?.libp2p && this.context.libp2p.isStarted) {
        const connections = this.context.libp2p.getConnections();
        for (const conn of connections) {
          try {
            await this.context.libp2p.dialProtocol(conn.remotePeer, "/music-network/1.0.0");
            this.musicPeers.add(conn.remotePeer.toString());
          } catch {
            // not a music network peer
          }
        }
      }
    }, 15000);
  }

  // ─── Public Utility Methods ───

  /**
   * Compute basic music stats: total files, genre distribution, top artists, connected peers
   */
  getMusicStats(): {
    totalMusicFiles: number;
    genreDistribution: Record<string, number>;
    topArtists: { artist: string; count: number }[];
    connectedMusicPeers: number;
  } {
    if (!this.context) {
      throw new Error("MusicNetworkPlugin: missing context");
    }

    const genreCount: Map<string, number> = new Map();
    const artistCount: Map<string, number> = new Map();
    let totalMusicFiles = 0;

    for (const file of Array.from(this.context.files.values())) {
      if (this.canHandleFile(file) && file.metadata) {
        totalMusicFiles++;
        const md = file.metadata as MusicMetadata;
        if (md.genre) {
          genreCount.set(md.genre, (genreCount.get(md.genre) || 0) + 1);
        }
        if (md.artist) {
          artistCount.set(md.artist, (artistCount.get(md.artist) || 0) + 1);
        }
      }
    }

    for (const [cid, rec] of this.discoveredTracks.entries()) {
      const md = rec.metadata;
      totalMusicFiles++;
      if (md.genre) {
        genreCount.set(md.genre, (genreCount.get(md.genre) || 0) + 1);
      }
      if (md.artist) {
        artistCount.set(md.artist, (artistCount.get(md.artist) || 0) + 1);
      }
    }

    const genreDistribution: Record<string, number> = {};
    for (const [g, count] of genreCount) {
      genreDistribution[g] = count;
    }

    const topArtists = Array.from(artistCount.entries())
      .sort(([, a], [, b]) => b - a)
      .slice(0, 10)
      .map(([artist, count]) => ({ artist, count }));

    return {
      totalMusicFiles,
      genreDistribution,
      topArtists,
      connectedMusicPeers: this.musicPeers.size,
    };
  }

  /** Fetch all locally stored music FileInfo */
  getAllMusicFiles(): FileInfo[] {
    if (!this.context) {
      throw new Error("MusicNetworkPlugin: missing context");
    }
    return Array.from(this.context.files.values()).filter((f) => this.canHandleFile(f));
  }
}

export * from "./types.js";

filename: packages/vinyl-peer-plugin-music/src/index.ts
filecontent:
export * from "./types.js";
export * from "./MusicPlugin.js";

filename: tsconfig.json
filecontent:
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "lib": ["ES2020", "DOM"],
    "moduleResolution": "Node",
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "jsx": "react",
    "outDir": "dist",
    "baseUrl": ".",
    "paths": {
      "vinyl-peer-protocol": ["vinyl-peer-protocol/dist"],
      "vinyl-peer-cli": ["vinyl-peer-cli/dist"],
      "vinyl-peer-plugin-music": ["vinyl-peer-plugin-music/dist"],
      "vinyl-peer-plugin-analytics": ["vinyl-peer-plugin-analytics/dist"],
      "vinyl-peer-plugin-replication": ["vinyl-peer-plugin-replication/dist"],
      "vinyl-peer-plugin-rs": ["vinyl-peer-plugin-rs/dist"],
      "vinyl-peer-plugin-sdk-generator": ["vinyl-peer-plugin-sdk-generator/dist"],
      "vinyl-peer-plugin-v": ["vinyl-peer-plugin-v/dist"],
      "vinyl-peer-plugin-monitor": ["vinyl-peer-plugin-monitor/dist"],
      "vinyl-peer-plugin-filecoin-bridge": ["vinyl-peer-plugin-filecoin-bridge/dist"],
      "vinyl-peer-plugin-auto-replication": ["vinyl-peer-plugin-auto-replication/dist"],
      "vinyl-peer-plugin-nameservice": ["vinyl-peer-plugin-nameservice/dist"],
      "vinyl-peer-plugin-advanced-sharding": ["vinyl-peer-plugin-advanced-sharding/dist"],
    },
    "declaration": true
  },
  "include": ["packages/**/*"],
    "ts-node": {
    "esm": false
  }
}

